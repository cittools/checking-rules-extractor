<HTML><HEAD>
<meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
<TITLE>Enabled Rules</TITLE></HEAD>
<BODY BGCOLOR=white><FONT FACE="Arial, Helvetica"><H1>Enabled Rules</H1>
<UL>
<LI><B><A HREF="BD.html">BugDetective (License Required) [BD]</A></B>
<UL>
<LI><B><A HREF="BD-MISC.html">Miscellaneous [BD-MISC]</A></B>
<UL>
<LI><A HREF="BD-MISC-TRANS.html">Always close transactions [BD-MISC-TRANS-1]</A>
</UL>
<LI><B><A HREF="BD-PB.html">Possible Bugs [BD-PB]</A></B>
<UL>
<LI><A HREF="BD-PB-ARRAY.html">Avoid accessing arrays out of bounds [BD-PB-ARRAY-1]</A>
<LI><A HREF="BD-PB-CC.html">Avoid conditions that always evaluate to the same value [BD-PB-CC-2]</A>
<LI><A HREF="BD-PB-DEREF.html">Avoid dereferencing before checking for null [BD-PB-DEREF-2]</A>
<LI><A HREF="BD-PB-NOTINIT.html">Avoid use before initialization [BD-PB-NOTINIT-1]</A>
<LI><A HREF="BD-PB-NP.html">Avoid null pointer dereferencing [BD-PB-NP-1]</A>
<LI><A HREF="BD-PB-OVERFFMT.html">Avoid buffer overflow due to defining incorrect format limits [BD-PB-OVERFFMT-1]</A>
<LI><A HREF="BD-PB-OVERFNZT.html">Avoid overflow due to reading a not zero terminated string [BD-PB-OVERFNZT-1]</A>
<LI><A HREF="BD-PB-OVERFRD.html">Avoid overflow when reading from a buffer [BD-PB-OVERFRD-1]</A>
<LI><A HREF="BD-PB-OVERFWR.html">Avoid overflow when writing to a buffer [BD-PB-OVERFWR-1]</A>
<LI><A HREF="BD-PB-SWITCH.html">Avoid switch with unreachable branches [BD-PB-SWITCH-2]</A>
<LI><A HREF="BD-PB-ZERO.html">Avoid division by zero [BD-PB-ZERO-1]</A>
</UL>
<LI><B><A HREF="BD-RES.html">Resources [BD-RES]</A></B>
<UL>
<LI><A HREF="BD-RES-BADFREEF.html">Ensure deallocation functions guarantee resource freeing [BD-RES-BADFREEF-1]</A>
<LI><A HREF="BD-RES-FREE.html">Do not use resources that have been freed [BD-RES-FREE-1]</A>
<LI><A HREF="BD-RES-INVFREE.html">Do not free resources using invalid pointers [BD-RES-INVFREE-1]</A>
<LI><A HREF="BD-RES-LEAKS.html">Ensure resources are freed [BD-RES-LEAKS-1]</A>
</UL>
<LI><B><A HREF="BD-SECURITY.html">Security [BD-SECURITY]</A></B>
<UL>
<LI><A HREF="BD-SECURITY-ARRAY.html">Avoid tainted data in array indexes [BD-SECURITY-ARRAY-1]</A>
<LI><A HREF="BD-SECURITY-INTOVERF.html">Protect against integer overflow/underflow from tainted data [BD-SECURITY-INTOVERF-1]</A>
<LI><A HREF="BD-SECURITY-OVERFRD.html">Avoid buffer read overflow from tainted data [BD-SECURITY-OVERFRD-1]</A>
<LI><A HREF="BD-SECURITY-OVERFWR.html">Avoid buffer write overflow from tainted data [BD-SECURITY-OVERFWR-1]</A>
<LI><A HREF="BD-SECURITY-TDCMD.html">Protect against command injection [BD-SECURITY-TDCMD-1]</A>
<LI><A HREF="BD-SECURITY-TDFNAMES.html">Protect against file name injection [BD-SECURITY-TDFNAMES-1]</A>
<LI><A HREF="BD-SECURITY-TDSQL.html">Protect against SQL injection [BD-SECURITY-TDSQL-1]</A>
</UL>
<LI><B><A HREF="BD-TRS.html">Threads & Synchronization [BD-TRS]</A></B>
<UL>
<LI><A HREF="BD-TRS-MUTEX.html">Do not abandon unreleased mutexes [BD-TRS-MUTEX-1]</A>
<LI><A HREF="BD-TRS-SLEEP.html">Do not use blocking functions in critical sections [BD-TRS-SLEEP-1]</A>
</UL>
</UL>
<LI><B><A HREF="CODSTA.html">Coding Conventions [CODSTA]</A></B>
<UL>
<LI><B><A HREF="CODSTA-CPP.html">Coding Conventions for C++ [CODSTA-CPP]</A></B>
<UL>
<LI><A HREF="CODSTA-CPP-01.html">Prefer iostream.h to stdio.h [CODSTA-CPP-01-5]</A>
<LI><A HREF="CODSTA-CPP-02.html">Have assignment operator returns a reference to *this; make assignment operator's return type a non-const reference to it's class' type [CODSTA-CPP-02-3]</A>
<LI><A HREF="CODSTA-CPP-03.html">Bitwise operators, comparison operators, logical operators, comma operator should be const [CODSTA-CPP-03-3]</A>
<LI><A HREF="CODSTA-CPP-04.html">Constructors allowing for conversion should be made explicit [CODSTA-CPP-04-1]</A>
<LI><A HREF="CODSTA-CPP-05.html">Do not use user-defined conversion functions [CODSTA-CPP-05-1]</A>
<LI><A HREF="CODSTA-CPP-06.html">Avoid returning handles to class data from member functions [CODSTA-CPP-06-3]</A>
<LI><A HREF="CODSTA-CPP-07.html">Postfix increment and decrement should be implemented in terms of their prefix counterparts [CODSTA-CPP-07-3]</A>
<LI><A HREF="CODSTA-CPP-08.html">Avoid overloading &amp;&amp;, || or , (comma) [CODSTA-CPP-08-3]</A>
<LI><A HREF="CODSTA-CPP-09.html">Avoid using reinterpret_cast [CODSTA-CPP-09-3]</A>
<LI><A HREF="CODSTA-CPP-10.html">Do not define structs that contain member functions [CODSTA-CPP-10-3]</A>
<LI><A HREF="CODSTA-CPP-11.html">Prefer C++-style casts [CODSTA-CPP-11-3]</A>
<LI><A HREF="CODSTA-CPP-12.html">Put classes that are used as base classes and classes that are used as member variables into separate include files [CODSTA-CPP-12-3]</A>
<LI><A HREF="CODSTA-CPP-13.html">Put classes that are used as function return type into separate include files [CODSTA-CPP-13-3]</A>
<LI><A HREF="CODSTA-CPP-14.html">Put classes that are used as argument types in function prototypes into separate include files [CODSTA-CPP-14-3]</A>
<LI><A HREF="CODSTA-CPP-15.html">Put functions that are used in the body of inline member function into separate include file [CODSTA-CPP-15-3]</A>
<LI><A HREF="CODSTA-CPP-16.html">When two operators are opposites (such as == and !=), it is appropriate to define both [CODSTA-CPP-16-3]</A>
<LI><A HREF="CODSTA-CPP-17.html">Do not use the 'struct' keyword to declare a variable in C++ [CODSTA-CPP-17-3]</A>
<LI><A HREF="CODSTA-CPP-18.html">Encapsulate global variables and constants, enumerated types, and typedefs in a class [CODSTA-CPP-18-5]</A>
<LI><A HREF="CODSTA-CPP-19.html">Declare at least one constructor to prevent the compiler from doing so [CODSTA-CPP-19-2]</A>
<LI><A HREF="CODSTA-CPP-20.html">If you'd like to support mixed-mode operations make operators a non-member functions [CODSTA-CPP-20-3]</A>
<LI><A HREF="CODSTA-CPP-21.html">Assignment operator must return const reference [CODSTA-CPP-21-5]</A>
<LI><A HREF="CODSTA-CPP-22.html">Prefer non-member non-friend functions to member functions [CODSTA-CPP-22-3]</A>
<LI><A HREF="CODSTA-CPP-23.html">Whenever a global function &nbsp;is &nbsp;referenced, use the :: operator [CODSTA-CPP-23-5]</A>
<LI><A HREF="CODSTA-CPP-24.html">Avoid making any assignment operator virtual. Do not return const T&amp; from assignment operator [CODSTA-CPP-24-3]</A>
<LI><A HREF="CODSTA-CPP-25.html">Consider making virtual functions nonpublic, and public functions nonvirtual [CODSTA-CPP-25-3]</A>
<LI><A HREF="CODSTA-CPP-26.html">Keep types and functions in separate namespaces unless they're specifically intended to work together [CODSTA-CPP-26-3]</A>
<LI><A HREF="CODSTA-CPP-27.html">Keep a type and its nonmember function interface in the same namespace [CODSTA-CPP-27-3]</A>
<LI><A HREF="CODSTA-CPP-28.html">When binary arithmetic operators are defined &nbsp;( + , - , * , / , ^ , % , | , &amp; , &gt;&gt; , &lt;&lt; ), assignment versions should be provided too [CODSTA-CPP-28-3]</A>
<LI><A HREF="CODSTA-CPP-29.html">Prefer the canonical forms of arithmetic and assignment operators [CODSTA-CPP-29-3]</A>
<LI><A HREF="CODSTA-CPP-30.html">Prefer non-member operators than member ones to support mixed-mode arithmetic [CODSTA-CPP-30-3]</A>
<LI><A HREF="CODSTA-CPP-31.html">Do not use the keyword 'explicit' for a constructor [CODSTA-CPP-31-5]</A>
<LI><A HREF="CODSTA-CPP-32.html">Member functions shall not be defined within the no-template class definition [CODSTA-CPP-32-3]</A>
<LI><A HREF="CODSTA-CPP-33.html">Member functions shall not be defined within the template class definition [CODSTA-CPP-33-3]</A>
<LI><A HREF="CODSTA-CPP-34.html">Avoid using static_cast on pointers [CODSTA-CPP-34-3]</A>
<LI><A HREF="CODSTA-CPP-35.html">Avoid dynamic_casts [CODSTA-CPP-35-3]</A>
<LI><A HREF="CODSTA-CPP-36.html">Avoid using global variables, global functions, and class in file outside namespaces [CODSTA-CPP-36-3]</A>
<LI><A HREF="CODSTA-CPP-37.html">Do not define class/struct/union inside function implementation [CODSTA-CPP-37-3]</A>
<LI><A HREF="CODSTA-CPP-38.html">Conversion operator, operator-&gt;, operator(), operator[] should be const [CODSTA-CPP-38-3]</A>
<LI><A HREF="CODSTA-CPP-39.html">Don't write namespace usings in a header file or before an #include [CODSTA-CPP-39-3]</A>
<LI><A HREF="CODSTA-CPP-40.html">Limiting the number of objects of a class [CODSTA-CPP-40-5]</A>
<LI><A HREF="CODSTA-CPP-41.html">Do not use the 'enum' keyword to declare a variable in C++ [CODSTA-CPP-41-3]</A>
<LI><A HREF="CODSTA-CPP-42.html">Do not declare member variables with the 'mutable' keyword [CODSTA-CPP-42-3]</A>
<LI><A HREF="CODSTA-CPP-43.html">Declare reference parameters as const references whenever possible [CODSTA-CPP-43-3]</A>
<LI><A HREF="CODSTA-CPP-44.html">Have the non-const version call the const version of member function instead of duplicating the const version definition [CODSTA-CPP-44-3]</A>
<LI><A HREF="CODSTA-CPP-45.html">In the private section of a class items shall be declared in the following order: Constructors, Destructor, Member Functions, Member Operator Function, Enumerations and others [CODSTA-CPP-45-3]</A>
<LI><A HREF="CODSTA-CPP-46.html">Order of scopes in class: public before all others [CODSTA-CPP-46-3]</A>
<LI><A HREF="CODSTA-CPP-47.html">Order of scopes in classes: protected before private [CODSTA-CPP-47-3]</A>
<LI><A HREF="CODSTA-CPP-48.html">In the protected section of a class items shall be declared in the following order: Constructors, Destructor, Member Functions, Member Operator Function, Enumerations and others [CODSTA-CPP-48-3]</A>
<LI><A HREF="CODSTA-CPP-49.html">In the public section of a class items shall be declared in the following order: Constructors, Destructor, Member Functions, Member Operator Function, Enumerations and others [CODSTA-CPP-49-3]</A>
<LI><A HREF="CODSTA-CPP-50.html">Do not use static keyword except inside functions and classes [CODSTA-CPP-50-3]</A>
<LI><A HREF="CODSTA-CPP-51.html">Do not define inline functions in source files [CODSTA-CPP-51-3]</A>
<LI><A HREF="CODSTA-CPP-52.html">Consider using the natural relationship between the assignment version of an operator and the stand-alone version [CODSTA-CPP-52-3]</A>
<LI><A HREF="CODSTA-CPP-53.html">Declare parameters or local variable as const whenever possible [CODSTA-CPP-53-3]</A>
<LI><A HREF="CODSTA-CPP-54.html">Member functions shall be declared const whenever possible [CODSTA-CPP-54-3]</A>
<LI><A HREF="CODSTA-CPP-55.html">Arrays shall not be used in interfaces [CODSTA-CPP-55-2]</A>
<LI><A HREF="CODSTA-CPP-56.html">A class, structure, or enumeration will not be declared in the definition of its type [CODSTA-CPP-56-3]</A>
<LI><A HREF="CODSTA-CPP-57.html">Namespaces will not be nested more than two levels deep [CODSTA-CPP-57-3]</A>
<LI><A HREF="CODSTA-CPP-58.html">The value returned by a function having a non-void return type that is not an overloaded operator shall always be used [CODSTA-CPP-58-3]</A>
<LI><A HREF="CODSTA-CPP-59.html">The C library shall not be used [CODSTA-CPP-59-3]</A>
<LI><A HREF="CODSTA-CPP-60.html">Only those escape sequences that are defined in ISO/IEC 14882:2003 shall be used [CODSTA-CPP-60-3]</A>
<LI><A HREF="CODSTA-CPP-61.html">Objects or functions with external linkage shall be declared in a header file [CODSTA-CPP-61-3]</A>
<LI><A HREF="CODSTA-CPP-62.html">NULL shall not be used as an integer value [CODSTA-CPP-62-3]</A>
<LI><A HREF="CODSTA-CPP-63.html">Literal zero (0) shall not be used as the null-pointer-constant [CODSTA-CPP-63-3]</A>
<LI><A HREF="CODSTA-CPP-64.html">The condition of an if-statement and the condition of an iteration-statement shall have type bool [CODSTA-CPP-64-3]</A>
<LI><A HREF="CODSTA-CPP-65.html">The first operand of a conditional-operator shall have type bool [CODSTA-CPP-65-1]</A>
<LI><A HREF="CODSTA-CPP-66.html">C-style casts (other than void casts) and functional notation casts (other than explicit constructor calls) shall not be used [CODSTA-CPP-66-3]</A>
<LI><A HREF="CODSTA-CPP-67.html">Each operand of the ! operator, the logical &amp;&amp; or the logical || operators shall have type bool [CODSTA-CPP-67-3]</A>
<LI><A HREF="CODSTA-CPP-68.html">The unary &amp; operator shall not be overloaded [CODSTA-CPP-68-3]</A>
<LI><A HREF="CODSTA-CPP-69.html">A for loop shall contain a single loop-counter which shall not have floating type [CODSTA-CPP-69-3]</A>
<LI><A HREF="CODSTA-CPP-70.html">If loop-counter is not modified by -- or ++, then, within condition, the loop-counter shall only be used as an operand to &lt;=, &lt;, &gt; or &gt;= [CODSTA-CPP-70-3]</A>
<LI><A HREF="CODSTA-CPP-71.html">The loop-counter shall be modified by one of: --, ++, -=n, or +=n; where n remains constant for the duration of the loop [CODSTA-CPP-71-3]</A>
<LI><A HREF="CODSTA-CPP-72.html">A loop-control-variable other than the loop-counter shall not be modified within condition or expression [CODSTA-CPP-72-3]</A>
<LI><A HREF="CODSTA-CPP-73.html">A loop-control-variable other than the loop-counter which is modified in statement shall have type bool [CODSTA-CPP-73-3]</A>
<LI><A HREF="CODSTA-CPP-74.html">There shall be no unnamed namespaces in header files [CODSTA-CPP-74-3]</A>
<LI><A HREF="CODSTA-CPP-75.html">using-directives shall not be used [CODSTA-CPP-75-3]</A>
<LI><A HREF="CODSTA-CPP-76.html">Multiple declarations for an identifier in the same namespace shall not straddle a using-declaration for that identifier [CODSTA-CPP-76-3]</A>
<LI><A HREF="CODSTA-CPP-77.html">Const member functions shall not return non-const pointers or references to class-data [CODSTA-CPP-77-3]</A>
<LI><A HREF="CODSTA-CPP-78.html">If a member function can be made static then it shall be made static, otherwise if it can be made const then it shall be made const [CODSTA-CPP-78-3]</A>
</UL>
<LI><A HREF="CODSTA-01.html">Array elements shall be accessed by the array operator [ ] [CODSTA-01-3]</A>
<LI><A HREF="CODSTA-02.html">Do not declare member variables as bit-fields [CODSTA-02-5]</A>
<LI><A HREF="CODSTA-03.html">Do not define constants via #define [CODSTA-03-3]</A>
<LI><A HREF="CODSTA-04.html">Do not declare local variables with the 'static' keyword [CODSTA-04-5]</A>
<LI><A HREF="CODSTA-05.html">Pointers to pointers should be avoided whenever possible [CODSTA-05-3]</A>
<LI><A HREF="CODSTA-06.html">Avoid using the '?:' operator [CODSTA-06-3]</A>
<LI><A HREF="CODSTA-07.html">If a function has no parameters, use ( ) instead of ( void ) [CODSTA-07-3]</A>
<LI><A HREF="CODSTA-08.html">Do not use break in for loops [CODSTA-08-2]</A>
<LI><A HREF="CODSTA-09.html">Do not cast pointers to functions to pointers to primitive types [CODSTA-09-3]</A>
<LI><A HREF="CODSTA-10.html">Storage type modifiers shall be associated with the type, not the variable or the function [CODSTA-10-3]</A>
<LI><A HREF="CODSTA-11.html">Assert liberally to document internal assumptions and invariants [CODSTA-11-5]</A>
<LI><A HREF="CODSTA-12.html">Avoid using shift operations instead of arithmetic operations [CODSTA-12-3]</A>
<LI><A HREF="CODSTA-13.html">Avoid pointer arithmetic [CODSTA-13-3]</A>
<LI><A HREF="CODSTA-14.html">Never convert consts to non-consts [CODSTA-14-3]</A>
<LI><A HREF="CODSTA-15.html">Do not declare the size of an array when the array is passed into a function as a parameter [CODSTA-15-2]</A>
<LI><A HREF="CODSTA-16.html">Do not declare the size of an array when the array is initialized [CODSTA-16-2]</A>
<LI><A HREF="CODSTA-17.html">Do not compare a pointer to NULL or assign NULL to a pointer; use 0 instead [CODSTA-17-3]</A>
<LI><A HREF="CODSTA-18.html">Prefer while statements over do statements [CODSTA-18-5]</A>
<LI><A HREF="CODSTA-19.html">Use the ctype.h facilities for character test [CODSTA-19-3]</A>
<LI><A HREF="CODSTA-20.html">EOS should be used to terminate a string rather than NULL [CODSTA-20-2]</A>
<LI><A HREF="CODSTA-21.html">When using enum, the values of each member should be explicitly declared [CODSTA-21-5]</A>
<LI><A HREF="CODSTA-22.html">Local variable or parameter names and class member variable or parent class/struct member variable names shall differ by more than a single character [CODSTA-22-1]</A>
<LI><A HREF="CODSTA-23.html">All 'if' statements should have an 'else' clause [CODSTA-23-3]</A>
<LI><A HREF="CODSTA-24.html">If FALSE is to be defined, and is not already defined, #define FALSE should be 0 [CODSTA-24-5]</A>
<LI><A HREF="CODSTA-25.html">If FALSE is to be defined, and is not already defined, enum value FALSE should be 0 [CODSTA-25-5]</A>
<LI><A HREF="CODSTA-26.html">Avoid magic numbers [CODSTA-26-3]</A>
<LI><A HREF="CODSTA-27.html">Avoid functions that modify global variables [CODSTA-27-3]</A>
<LI><A HREF="CODSTA-28.html">Define fields for union declarations [CODSTA-28-5]</A>
<LI><A HREF="CODSTA-29.html">&quot;#define&quot; or enum constants should be used instead of hard coded values whenever possible [CODSTA-29-3]</A>
<LI><A HREF="CODSTA-30.html">Avoid returning handles to function parameters [CODSTA-30-3]</A>
<LI><A HREF="CODSTA-31.html">Never use explicit type conversions (casts) [CODSTA-31-3]</A>
<LI><A HREF="CODSTA-32.html">Do not write logical expressions of the type if(test) or if(!test) &nbsp;when test is a pointer [CODSTA-32-3]</A>
<LI><A HREF="CODSTA-33.html">Do not use operator ++ or -- in the conditional expression of if, while, or switch [CODSTA-33-3]</A>
<LI><A HREF="CODSTA-34.html">Use a typedef to simplify program syntax when declaring function pointers [CODSTA-34-3]</A>
<LI><A HREF="CODSTA-35.html">Always provide a default branch for switch statements [CODSTA-35-3]</A>
<LI><A HREF="CODSTA-36.html">Pass built-in-types by value unless you are modifying them [CODSTA-36-3]</A>
<LI><A HREF="CODSTA-37.html">Do not use a #define that prevents the compiler from checking types except ones used only in #ifs and #elifs conditions [CODSTA-37-3]</A>
<LI><A HREF="CODSTA-38.html">Do not use a #define that prevents the compiler from checking types [CODSTA-38-3]</A>
<LI><A HREF="CODSTA-39.html">Avoid internal or external name conflict with a C++ reserved word [CODSTA-39-1]</A>
<LI><A HREF="CODSTA-40.html">'void' should be used when a function is passed or returns no values [CODSTA-40-3]</A>
<LI><A HREF="CODSTA-41.html">Avoid switch statements with only one case [CODSTA-41-4]</A>
<LI><A HREF="CODSTA-42.html">If TRUE is to be defined, and is not already defined, #define TRUE should be 1 [CODSTA-42-5]</A>
<LI><A HREF="CODSTA-43.html">If TRUE is to be defined, and is not already defined, enum value TRUE should be 1 [CODSTA-43-5]</A>
<LI><A HREF="CODSTA-44.html">Local variables and variables of class/parent classes/parent structs should have different name [CODSTA-44-1]</A>
<LI><A HREF="CODSTA-45.html">Parameters and variables of class/parent classes/parent structs should have different name [CODSTA-45-1]</A>
<LI><A HREF="CODSTA-46.html">Use positive logic rather than negative logic whenever practical [CODSTA-46-5]</A>
<LI><A HREF="CODSTA-47.html">All structures should have typedefs [CODSTA-47-3]</A>
<LI><A HREF="CODSTA-48.html">The following digraphs will not be used &lt;%, %&gt;, &lt;:, :&gt;, %:, %:%: [CODSTA-48-3]</A>
<LI><A HREF="CODSTA-49.html">Null initialize or increment expressions in for loops will not be used; a while loop will be used instead [CODSTA-49-3]</A>
<LI><A HREF="CODSTA-50.html">Hexadecimal constants will be represented using all uppercase letters [CODSTA-50-3]</A>
<LI><A HREF="CODSTA-51.html">Literal suffixes shall use uppercase rather than lowercase letters [CODSTA-51-2]</A>
<LI><A HREF="CODSTA-52.html">The initialization expression in a for loop will perform no actions other than to initialize the value of a single for loop parameter [CODSTA-52-3]</A>
<LI><A HREF="CODSTA-53.html">The increment expression in a for loop will perform no action other than to change a single loop parameter to the next value for the loop [CODSTA-53-3]</A>
<LI><A HREF="CODSTA-54.html">Every switch statement will have at least two cases and a potential default [CODSTA-54-3]</A>
<LI><A HREF="CODSTA-55.html">Enumeration types shall be used instead of integer types (and constants) as case labels [CODSTA-55-2]</A>
<LI><A HREF="CODSTA-56.html">All 'case' and 'default' labels of switch statement should have an explicit break or a return statement, or 'fall through' comment [CODSTA-56-3]</A>
<LI><A HREF="CODSTA-57.html">Suspicious use of semicolon [CODSTA-57-4]</A>
<LI><A HREF="CODSTA-58.html">Cast to void is not allowed [CODSTA-58-4]</A>
<LI><A HREF="CODSTA-59.html">Hardcoded array declarations and 'malloc' calls should not be used [CODSTA-59-4]</A>
<LI><A HREF="CODSTA-60.html">Avoid comparing values with TRUE macro/enum constant using equality operators (&quot;==&quot;, &quot;!=&quot;) [CODSTA-60-3]</A>
<LI><A HREF="CODSTA-61.html">The final clause of a switch statement shall be the default-clause [CODSTA-61-3]</A>
<LI><A HREF="CODSTA-62.html">A cast shall not convert a pointer to a function to any other pointer type, including a pointer to function type [CODSTA-62-3]</A>
<LI><A HREF="CODSTA-63.html">Bitwise operators shall only be applied to operands of unsigned underlying type [CODSTA-63-3]</A>
<LI><A HREF="CODSTA-64.html">An unconditional throw or break statement shall terminate every non-empty switch-clause [CODSTA-64-3]</A>
<LI><A HREF="CODSTA-65.html">An object with integer type or pointer to void type shall not be converted to an object with pointer type [CODSTA-65-3]</A>
<LI><A HREF="CODSTA-66.html">Non-constant operands to a binary bitwise operator shall have the same underlying type [CODSTA-66-3]</A>
<LI><A HREF="CODSTA-67.html">The types used for an object, a function return type, or a function parameter shall be token-for-token identical in all declarations and re-declarations [CODSTA-67-3]</A>
<LI><A HREF="CODSTA-68.html">A &quot;U&quot; suffix shall be applied to all octal or hexadecimal integer literals of unsigned type [CODSTA-68-3]</A>
<LI><A HREF="CODSTA-69.html">Expressions with type (plain) char and wchar_t shall not be used as operands to built-in operators other than &nbsp;=, &nbsp;==, != and the unary &amp; operator [CODSTA-69-3]</A>
<LI><A HREF="CODSTA-70.html">Expressions with type enum shall not be used as operands to built-in operators other than &nbsp;[ ], &nbsp;=, ==, !=, &lt;, &lt;=, &gt;, &gt;=, and the unary &amp; operator [CODSTA-70-3]</A>
<LI><A HREF="CODSTA-71.html">Named bit-fields with signed integer type shall have a length of more than one bit [CODSTA-71-3]</A>
<LI><A HREF="CODSTA-73.html">Assembler instructions shall only be introduced using the asm declaration [CODSTA-73-3]</A>
<LI><A HREF="CODSTA-74.html">Bit-fields shall not have enum type [CODSTA-74-3]</A>
<LI><A HREF="CODSTA-75.html">Bit-fields shall be either bool type or an explicitly unsigned or signed integral type [CODSTA-75-3]</A>
<LI><A HREF="CODSTA-76.html">The identifier main shall not be used for a function other than the global function main [CODSTA-76-3]</A>
<LI><A HREF="CODSTA-77.html">The goto statement shall jump to a label declared later in the same function body [CODSTA-77-3]</A>
<LI><A HREF="CODSTA-78.html">Any label referenced by a goto statement shall be declared in the same block, or in a block enclosing the goto statement [CODSTA-78-3]</A>
<LI><A HREF="CODSTA-79.html">For any iteration statement there shall be no more than one break or goto statement used for loop termination [CODSTA-79-3]</A>
<LI><A HREF="CODSTA-80.html">The continue statement shall only be used within a well formed for loop [CODSTA-80-3]</A>
<LI><A HREF="CODSTA-81.html">If a function has internal linkage then all redeclarations shall include the static storage class specifier [CODSTA-81-3]</A>
<LI><A HREF="CODSTA-82.html">Avoid infinite loops [CODSTA-82-3]</A>
<LI><A HREF="CODSTA-83.html">All loops must have a fixed upper or lower bound [CODSTA-83-3]</A>
<LI><A HREF="CODSTA-85.html">Avoid exit points within infinite loops [CODSTA-85-3]</A>
<LI><A HREF="CODSTA-86.html">The validity of parameters must be checked inside each function [CODSTA-86-3]</A>
<LI><A HREF="CODSTA-87.html">Use no more than one level of dereferencing [CODSTA-87-3]</A>
<LI><A HREF="CODSTA-88.html">Function pointers are not permitted [CODSTA-88-3]</A>
<LI><A HREF="CODSTA-89.html">The declaration should not contain more than one level of pointer indirection [CODSTA-89-3]</A>
<LI><A HREF="CODSTA-90.html">Each operand of a logical '&amp;&amp;' or '||' shall be a postfix-expression [CODSTA-90-3]</A>
<LI><A HREF="CODSTA-91.html">A function shall have at most one exit point [CODSTA-91-3]</A>
</UL>
<LI><B><A HREF="COMMENT.html">Comments [COMMENT]</A></B>
<UL>
<LI><A HREF="COMMENT-01.html">Prefer C++ style comment [COMMENT-01-3]</A>
<LI><A HREF="COMMENT-02.html">Provide copyright information [COMMENT-02-3]</A>
<LI><A HREF="COMMENT-03.html">Comment every file [COMMENT-03-3]</A>
<LI><A HREF="COMMENT-04.html">Comment every function [COMMENT-04-3]</A>
<LI><A HREF="COMMENT-05.html">Each variable declaration should be commented [COMMENT-05-3]</A>
<LI><A HREF="COMMENT-06.html">Each typedef should be commented [COMMENT-06-3]</A>
<LI><A HREF="COMMENT-07.html">Each enumeration value should be commented [COMMENT-07-3]</A>
<LI><A HREF="COMMENT-08.html">Each structure member variable should be commented [COMMENT-08-3]</A>
<LI><A HREF="COMMENT-09.html">All usage of assembler shall be documented [COMMENT-09-3]</A>
<LI><A HREF="COMMENT-10.html">Use of floating-point arithmetic shall be documented [COMMENT-10-3]</A>
</UL>
<LI><B><A HREF="EXCEPT.html">Exceptions [EXCEPT]</A></B>
<UL>
<LI><A HREF="EXCEPT-01.html">Never allow an exception to be thrown from a destructor, deallocation, and swap [EXCEPT-01-1]</A>
<LI><A HREF="EXCEPT-02.html">Throw by value, catch by reference [EXCEPT-02-1]</A>
<LI><A HREF="EXCEPT-03.html">Do not throw from within destructor [EXCEPT-03-1]</A>
<LI><A HREF="EXCEPT-04.html">All exceptions should be rethrown or logged with standard logger [EXCEPT-04-2]</A>
<LI><A HREF="EXCEPT-05.html">C++ exceptions shall not be used (i.e. throw, catch and try shall not be used.) [EXCEPT-05-2]</A>
<LI><A HREF="EXCEPT-06.html">There should be at least one exception handler to catch all otherwise unhandled exceptions [EXCEPT-06-3]</A>
<LI><A HREF="EXCEPT-07.html">An empty throw (throw;) shall only be used in the compound-statement of a catch handler [EXCEPT-07-3]</A>
<LI><A HREF="EXCEPT-08.html">Exceptions shall be raised only after start-up and before termination of the program [EXCEPT-08-3]</A>
<LI><A HREF="EXCEPT-09.html">An exception object should not have pointer type [EXCEPT-09-3]</A>
<LI><A HREF="EXCEPT-10.html">Control shall not be transferred into a try or catch block using a goto or a switch statement [EXCEPT-10-3]</A>
<LI><A HREF="EXCEPT-11.html">The assignment-expression of a throw statement shall not itself cause an exception to be thrown [EXCEPT-11-1]</A>
<LI><A HREF="EXCEPT-12.html">NULL shall not be thrown explicitly [EXCEPT-12-3]</A>
<LI><A HREF="EXCEPT-13.html">Each exception explicitly thrown in the code shall have a handler of a compatible type in all call paths that could lead to that point [EXCEPT-13-3]</A>
<LI><A HREF="EXCEPT-14.html">Where a function's declaration includes an exception-specification, the function shall only be capable of throwing exceptions of the indicated type(s) [EXCEPT-14-3]</A>
<LI><A HREF="EXCEPT-15.html">A class type exception shall always be caught by reference [EXCEPT-15-3]</A>
<LI><A HREF="EXCEPT-16.html">Handlers of a function-try-block implementation of a class constructor or destructor shall not reference nonstatic members from this class or its bases [EXCEPT-16-3]</A>
<LI><A HREF="EXCEPT-17.html">Where multiple handlers are provided in a single try-catch statement or function-try-block for a derived class and some or all of its bases, the handlers shall be ordered most-derived to base class [EXCEPT-17-3]</A>
<LI><A HREF="EXCEPT-18.html">Each exception explicitly thrown in the code shall have a handler of a compatible type in all call paths that could lead to that point [EXCEPT-18-3]</A>
</UL>
<LI><B><A HREF="FORMAT.html">Formatting [FORMAT]</A></B>
<UL>
<LI><A HREF="FORMAT-01.html">Tabs that do not use ASCII spaces shall not be used [FORMAT-01-5]</A>
<LI><A HREF="FORMAT-02.html">Opening curly brace '{' shall appear on a line by themselves [FORMAT-02-3]</A>
<LI><A HREF="FORMAT-03.html">Closing curly brace '}' shall appear on a line by themselves [FORMAT-03-3]</A>
<LI><A HREF="FORMAT-04.html">Physical lines should be less than eighty characters [FORMAT-04-3]</A>
<LI><A HREF="FORMAT-05.html">The length of a macro should not exceed 10 lines [FORMAT-05-3]</A>
<LI><A HREF="FORMAT-06.html">Only one statement shall be allowed per line [FORMAT-06-3]</A>
<LI><A HREF="FORMAT-07.html">There shall be a single ASCII space character preceding assignment operators [FORMAT-07-3]</A>
<LI><A HREF="FORMAT-08.html">There shall be a single ASCII space character following assignment operators [FORMAT-08-3]</A>
<LI><A HREF="FORMAT-09.html">There shall be a single ASCII space character preceding bitwise operators [FORMAT-09-3]</A>
<LI><A HREF="FORMAT-10.html">There shall be a single ASCII space character following bitwise operators [FORMAT-10-3]</A>
<LI><A HREF="FORMAT-11.html">There shall be a single ASCII space character preceding and following bitwise operator '&amp;' [FORMAT-11-3]</A>
<LI><A HREF="FORMAT-12.html">There shall be a single ASCII space character between a conditional statement keyword and its opening parenthesis [FORMAT-12-3]</A>
<LI><A HREF="FORMAT-13.html">There shall be a maximum of 1 ASCII space character following the opening parenthesis in conditional statements [FORMAT-13-3]</A>
<LI><A HREF="FORMAT-14.html">There shall be a single ASCII space character preceding ternary conditional operator [FORMAT-14-3]</A>
<LI><A HREF="FORMAT-15.html">There shall be a single ASCII space character following ternary conditional operator [FORMAT-15-3]</A>
<LI><A HREF="FORMAT-16.html">There shall be a single ASCII space character preceding and following relational and equality operators [FORMAT-16-3]</A>
<LI><A HREF="FORMAT-17.html">There shall be no white space following a primary operator [FORMAT-17-3]</A>
<LI><A HREF="FORMAT-18.html">There shall be no white space preceding a primary operator [FORMAT-18-3]</A>
<LI><A HREF="FORMAT-19.html">There shall be a single ASCII space character following all commas [FORMAT-19-3]</A>
<LI><A HREF="FORMAT-20.html">There shall be a single ASCII space character following all semicolons [FORMAT-20-3]</A>
<LI><A HREF="FORMAT-21.html">There shall be no white space between a prefix unary operator and its operand [FORMAT-21-3]</A>
<LI><A HREF="FORMAT-22.html">There shall be no white space between a postfix unary operator and its operand [FORMAT-22-3]</A>
<LI><A HREF="FORMAT-23.html">There shall be no white spaces between the &quot;return&quot; or &nbsp;&quot;sizeof &quot; statements &nbsp;and its opening parenthesis [FORMAT-23-3]</A>
<LI><A HREF="FORMAT-24.html">There shall be no white spaces surrounding &quot;return&quot; or &nbsp;&quot;sizeof &quot; statements argument or expression [FORMAT-24-3]</A>
<LI><A HREF="FORMAT-25.html">Parenthesis shall be used with the &quot;return&quot; and &quot;sizeof&quot; statements [FORMAT-25-3]</A>
<LI><A HREF="FORMAT-26.html">There shall be a single ASCII space character preceding and following logical operators [FORMAT-26-3]</A>
<LI><A HREF="FORMAT-27.html">Line should be indented by a multiple of four spaces [FORMAT-27-3]</A>
<LI><A HREF="FORMAT-28.html">In a function definition, the return type of the function should be written on a separate line directly above the function name [FORMAT-28-3]</A>
<LI><A HREF="FORMAT-29.html">Multiple variable declarations shall not be allowed on the same line [FORMAT-29-3]</A>
<LI><A HREF="FORMAT-30.html">Place left parenthesis directly after function name [FORMAT-30-3]</A>
<LI><A HREF="FORMAT-31.html">Separate logical tests in conditional expressions [FORMAT-31-3]</A>
<LI><A HREF="FORMAT-32.html">The dereference operator `*' and the address-of operator `&amp;' should be directly connected with the type names [FORMAT-32-3]</A>
<LI><A HREF="FORMAT-33.html">Each variable should be declared in a separate declaration statement [FORMAT-33-3]</A>
<LI><A HREF="FORMAT-34.html">Braces &quot;{}&quot; which enclose a block should be placed in the same column [FORMAT-34-3]</A>
<LI><A HREF="FORMAT-35.html">When declaring functions, the leading parenthesis and the first argument are to be written on the same line as the function name [FORMAT-35-3]</A>
<LI><A HREF="FORMAT-36.html">Sibling statement lines should be indented to the same level [FORMAT-36-3]</A>
<LI><A HREF="FORMAT-37.html">First line in control statement body should be indented more than control statement keyword [FORMAT-37-3]</A>
<LI><A HREF="FORMAT-38.html">When declaring functions with more than 2 parameters, the leading parenthesis and the first argument are to be written on the same line as the function name, each additional argument will be written on a separate line [FORMAT-38-3]</A>
</UL>
<LI><B><A HREF="INIT.html">Initialization [INIT]</A></B>
<UL>
<LI><A HREF="INIT-01.html">Headers should not contain any initialization [INIT-01-3]</A>
<LI><A HREF="INIT-02.html">Do not initialize unsigned integer variables with signed constants [INIT-02-3]</A>
<LI><A HREF="INIT-03.html">Initialize all variables [INIT-03-3]</A>
<LI><A HREF="INIT-04.html">Initialize all pointer variables [INIT-04-2]</A>
<LI><A HREF="INIT-05.html">Do not initialize a reference to an object whose address can be changed [INIT-05-1]</A>
<LI><A HREF="INIT-06.html">All member variables should be initialized in constructor [INIT-06-1]</A>
<LI><A HREF="INIT-07.html">Make class members' initialization explicit by providing user-defined constructor [INIT-07-3]</A>
<LI><A HREF="INIT-08.html">User-defined constructor must be provided to ensure the proper initialization of dynamically allocated class objects [INIT-08-3]</A>
<LI><A HREF="INIT-09.html">Initialize static class members [INIT-09-1]</A>
<LI><A HREF="INIT-10.html">List members in an initialization list in the order in which they are declared [INIT-10-3]</A>
<LI><A HREF="INIT-11.html">Assign to all data members in operator= [INIT-11-2]</A>
<LI><A HREF="INIT-12.html">Avoid initialization order problems across translation units [INIT-12-3]</A>
<LI><A HREF="INIT-13.html">Do not assume that members are initialized in any special order in constructors [INIT-13-3]</A>
<LI><A HREF="INIT-14.html">Prefer initialization to assignment in constructors [INIT-14-5]</A>
</UL>
<LI><B><A HREF="JSF.html">Joint Strike Fighter [JSF]</A></B>
<UL>
<LI><A HREF="JSF-1.html">Any one function (or method) will contain no more than 200 logical source lines of code (L-SLOCs) [JSF-1-3]</A>
<LI><A HREF="JSF-10.html">Values of character types shall be restricted to a defined and documented subset of ISO 10646-1 [JSF-10-3]</A>
<LI><A HREF="JSF-107.html">Always declare functions at file scope [JSF-107-2]</A>
<LI><A HREF="JSF-108.html">Do not use functions with variable numbers of arguments [JSF-108-2]</A>
<LI><A HREF="JSF-109.html">Member functions shall not be defined within the no-template class definition [JSF-109-4]</A>
<LI><A HREF="JSF-11.html">Trigraphs shall not be used [JSF-11-3]</A>
<LI><A HREF="JSF-110.html">Functions with more than 7 parameters will not be used [JSF-110-3]</A>
<LI><A HREF="JSF-111.html">Never return a reference to a local object [JSF-111-2]</A>
<LI><A HREF="JSF-112.html">Never return a dereferenced local pointer initialized by new in this function scope [JSF-112-4]</A>
<LI><A HREF="JSF-113.html">A function shall have a single point of exit at the end of the function [JSF-113-3]</A>
<LI><A HREF="JSF-114.html">All exit paths from a function with non-void return type shall have an explicit return statement with an expression [JSF-114-2]</A>
<LI><A HREF="JSF-115.html">If a function return error information, then that error information should be tested [JSF-115-3]</A>
<LI><A HREF="JSF-116.html">Pass built-in-types by value unless you are modifying them [JSF-116-4]</A>
<LI><A HREF="JSF-117.1.html">Declare reference parameters as const references whenever possible [JSF-117.1-4]</A>
<LI><A HREF="JSF-117_a.html">Avoid slicing function arguments / return value [JSF-117_a-4]</A>
<LI><A HREF="JSF-117_b.html">The class object should be passed by reference if the class has non-static pointers and has no declared copy constructor [JSF-117_b-4]</A>
<LI><A HREF="JSF-118.html">A pointer parameter in a function prototype should be declared as pointer to const if the pointer is not used to modify the addressed object [JSF-118-4]</A>
<LI><A HREF="JSF-119.html">Functions shall not call themselves, either directly or indirectly [JSF-119-2]</A>
<LI><A HREF="JSF-12.html">The following digraphs will not be used &lt;%, %&gt;, &lt;:, :&gt;, %:, %:%: [JSF-12-3]</A>
<LI><A HREF="JSF-121.html">Only functions with 1 or 2 statements should be considered candidates for inline functions [JSF-121-4]</A>
<LI><A HREF="JSF-122.html">Trivial accessor and mutator functions should be inlined [JSF-122-4]</A>
<LI><A HREF="JSF-123.html">The number of accessor and mutator functions should be minimized [JSF-123-4]</A>
<LI><A HREF="JSF-124.html">Trivial forwarding functions should be inlined [JSF-124-4]</A>
<LI><A HREF="JSF-125_a.html">Pass objects by reference instead of by value [JSF-125_a-2]</A>
<LI><A HREF="JSF-125_b.html">Consider using op= instead of stand-alone op [JSF-125_b-2]</A>
<LI><A HREF="JSF-126.html">Prefer C++ style comment [JSF-126-2]</A>
<LI><A HREF="JSF-127.html">Sections of code should not be &quot;commented out&quot; [JSF-127-2]</A>
<LI><A HREF="JSF-13.html">Do not use wide string literals [JSF-13-3]</A>
<LI><A HREF="JSF-132_a.html">Each variable declaration should be commented [JSF-132_a-3]</A>
<LI><A HREF="JSF-132_b.html">Each typedef should be commented [JSF-132_b-3]</A>
<LI><A HREF="JSF-132_c.html">Each enumeration value should be commented [JSF-132_c-3]</A>
<LI><A HREF="JSF-132_d.html">Each structure member variable should be commented [JSF-132_d-3]</A>
<LI><A HREF="JSF-133_a.html">Comment every file [JSF-133_a-3]</A>
<LI><A HREF="JSF-133_b.html">Provide copyright information [JSF-133_b-3]</A>
<LI><A HREF="JSF-134.html">Comment every function [JSF-134-4]</A>
<LI><A HREF="JSF-135_a.html">Identifiers in an inner scope shall not use the same name as an identifier in an outer scope, and therefore hide that identifier [JSF-135_a-2]</A>
<LI><A HREF="JSF-135_b.html">Identifiers in an inner scope shall not use the same name as an identifier in an outer scope, and therefore hide that identifier [JSF-135_b-2]</A>
<LI><A HREF="JSF-136.html">Declare objects at function scope [JSF-136-4]</A>
<LI><A HREF="JSF-137.html">Make declarations at file scope static where possible [JSF-137-4]</A>
<LI><A HREF="JSF-138_a.html">Use consistent linkage for identifiers [JSF-138_a-2]</A>
<LI><A HREF="JSF-138_b.html">The static storage class specifier shall be used in definitions and declarations of objects and functions that have internal linkage [JSF-138_b-2]</A>
<LI><A HREF="JSF-139.html">External object should not be declared in more than one file [JSF-139-3]</A>
<LI><A HREF="JSF-14.html">Literal suffixes shall use uppercase rather than lowercase letters [JSF-14-2]</A>
<LI><A HREF="JSF-140.html">Do not use register storage class [JSF-140-2]</A>
<LI><A HREF="JSF-141.html">A class, structure, or enumeration will not be declared in the definition of its type [JSF-141-3]</A>
<LI><A HREF="JSF-142_a.html">All automatic variables shall have been assigned a value before being used [JSF-142_a-2]</A>
<LI><A HREF="JSF-142_b.html">Initialize all variables [JSF-142_b-2]</A>
<LI><A HREF="JSF-143.html">Variables will not be introduced until they can be initialized with meaningful values [JSF-143-2]</A>
<LI><A HREF="JSF-144.html">Braces shall be used to indicate and match the structure in the non-zero initialization of arrays and structures [JSF-144-2]</A>
<LI><A HREF="JSF-145.html">In an enumerator list, the &quot;=&quot; construct shall not be used to explicitly initialise members other than the first, unless all items are explicitly initialised [JSF-145-2]</A>
<LI><A HREF="JSF-147.html">The underlying bit representations of floating point numbers shall not be used [JSF-147-2]</A>
<LI><A HREF="JSF-148.html">Enumeration types shall be used instead of integer types (and constants) as case labels [JSF-148-2]</A>
<LI><A HREF="JSF-149.html">Octal constants (other than zero) and octal escape sequences shall not be used [JSF-149-2]</A>
<LI><A HREF="JSF-150.html">Hexadecimal constants will be represented using all uppercase letters [JSF-150-3]</A>
<LI><A HREF="JSF-151.html">Avoid magic numbers [JSF-151-3]</A>
<LI><A HREF="JSF-151.1.html">A string literal shall not be modified [JSF-151.1-2]</A>
<LI><A HREF="JSF-152.html">Multiple variable declarations shall not be allowed on the same line [JSF-152-2]</A>
<LI><A HREF="JSF-153.html">Unions shall not be used [JSF-153-2]</A>
<LI><A HREF="JSF-154.html">Bit fields shall only be defined to be of type unsigned int or signed int [JSF-154-2]</A>
<LI><A HREF="JSF-156.html">All the members of a structure (or union) shall be named [JSF-156-2]</A>
<LI><A HREF="JSF-157.html">The right-hand operand of a logical &amp;&amp; or || operator shall not contain side effects [JSF-157-2]</A>
<LI><A HREF="JSF-158.html">Each operand of a logical '&amp;&amp;' or '||' shall be a postfix-expression [JSF-158-2]</A>
<LI><A HREF="JSF-159.html">Avoid overloading &amp;&amp;, || or , (comma) [JSF-159-2]</A>
<LI><A HREF="JSF-160.html">Assignment operators shall not be used in expressions that yield a Boolean value [JSF-160-2]</A>
<LI><A HREF="JSF-162_a.html">Avoid implicit conversions between signed and unsigned integer types [JSF-162_a-2]</A>
<LI><A HREF="JSF-162_b.html">Avoid implicit conversions between signed and unsigned integer types [JSF-162_b-2]</A>
<LI><A HREF="JSF-162_c.html">Use explicit type conversions for arithmetic using signed and unsigned values [JSF-162_c-2]</A>
<LI><A HREF="JSF-163.html">Unsigned arithmetic shall not be used [JSF-163-2]</A>
<LI><A HREF="JSF-164.html">The right-hand operand of a shift operator shall lie between zero and one less than the width in bits of the underlying type of the left-hand operand [JSF-164-2]</A>
<LI><A HREF="JSF-164.1.html">The left-hand operand of a right-shift operator shall not have a negative value [JSF-164.1-2]</A>
<LI><A HREF="JSF-165.html">The unary minus operator shall not be applied to an expression whose underlying type is unsigned [JSF-165-2]</A>
<LI><A HREF="JSF-166.html">The sizeof operator shall not be used on expressions that contain side effects [JSF-166-3]</A>
<LI><A HREF="JSF-167.html">Document integer division [JSF-167-2]</A>
<LI><A HREF="JSF-168_a.html">The comma operator shall not be used, except in the control expression of a for loop [JSF-168_a-2]</A>
<LI><A HREF="JSF-168_b.html">The comma operator shall not be used [JSF-168_b-2]</A>
<LI><A HREF="JSF-169.html">Pointers to pointers should be avoided whenever possible [JSF-169-4]</A>
<LI><A HREF="JSF-17.html">The error indicator errno shall not be used [JSF-17-2]</A>
<LI><A HREF="JSF-170_a.html">The declaration of objects should contain no more than 2 levels of pointer indirection [JSF-170_a-2]</A>
<LI><A HREF="JSF-170_b.html">The declaration of objects should contain no more than 2 levels of pointer indirection [JSF-170_b-2]</A>
<LI><A HREF="JSF-171.html">&gt;, &gt;=, &lt;, &lt;= shall not be applied to pointer types except where they point to the same array [JSF-171-2]</A>
<LI><A HREF="JSF-173.html">The address of an object with automatic storage shall not be assigned to another object that may persist after the first object has ceased to exist [JSF-173-2]</A>
<LI><A HREF="JSF-174_a.html">The NULL pointer shall not be dereferenced [JSF-174_a-2]</A>
<LI><A HREF="JSF-174_b.html">The NULL pointer shall not be dereferenced [JSF-174_b-2]</A>
<LI><A HREF="JSF-175.html">Do not compare a pointer to NULL or assign NULL to a pointer; use 0 instead [JSF-175-2]</A>
<LI><A HREF="JSF-176.html">Use a typedef to simplify program syntax when declaring function pointers [JSF-176-3]</A>
<LI><A HREF="JSF-177.html">Do not use user-defined conversion functions [JSF-177-4]</A>
<LI><A HREF="JSF-178.html">Avoid casts down the inheritance hierarchy [JSF-178-2]</A>
<LI><A HREF="JSF-179.html">A pointer to a virtual base class shall only be cast to a pointer to a derived class by means of dynamic_cast [JSF-179-2]</A>
<LI><A HREF="JSF-18.html">The macro offsetof, in library stddef.h, shall not be used [JSF-18-2]</A>
<LI><A HREF="JSF-180_a.html">Implicit conversions which may result in a loss of information shall not be used [JSF-180_a-2]</A>
<LI><A HREF="JSF-180_c.html">Avoid implicit conversions between integer and floating types [JSF-180_c-2]</A>
<LI><A HREF="JSF-180_d.html">Avoid implicit conversions of complex expressions [JSF-180_d-2]</A>
<LI><A HREF="JSF-180_e.html">Avoid implicit conversions from wider to narrower types [JSF-180_e-2]</A>
<LI><A HREF="JSF-180_f.html">Avoid implicit conversions of function return expressions [JSF-180_f-2]</A>
<LI><A HREF="JSF-180_h.html">Avoid implicit conversions of function arguments [JSF-180_h-2]</A>
<LI><A HREF="JSF-181_a.html">Avoid unnecessary explicit cast from derived to a base class [JSF-181_a-3]</A>
<LI><A HREF="JSF-181_b.html">Instead of casting a long type operand of an expression to int cast the result of the expression [JSF-181_b-3]</A>
<LI><A HREF="JSF-181_c.html">Do not cast an int pointer to a long pointer [JSF-181_c-3]</A>
<LI><A HREF="JSF-181_d.html">A pointer to a long should not be casted to an int pointer [JSF-181_d-3]</A>
<LI><A HREF="JSF-181_e.html">Do not cast from &quot;shorter&quot; type to &quot;longer&quot; type [JSF-181_e-3]</A>
<LI><A HREF="JSF-182_a.html">A cast should not convert a pointer type to an integral type [JSF-182_a-2]</A>
<LI><A HREF="JSF-182_b.html">A cast should not convert an integral type to a pointer type [JSF-182_b-2]</A>
<LI><A HREF="JSF-183.html">Never use explicit type conversions (casts) [JSF-183-4]</A>
<LI><A HREF="JSF-184_a.html">Avoid implicit conversions of float type resulting in a loss of information [JSF-184_a-2]</A>
<LI><A HREF="JSF-184_b.html">Avoid implicit conversions of float type resulting in a loss of information [JSF-184_b-2]</A>
<LI><A HREF="JSF-185.html">Prefer C++-style casts [JSF-185-2]</A>
<LI><A HREF="JSF-186_a.html">There shall be no unreachable code in &quot;else&quot; block [JSF-186_a-2]</A>
<LI><A HREF="JSF-186_b.html">There shall be no unreachable code after 'return', 'break', 'continue', and 'goto' statements [JSF-186_b-2]</A>
<LI><A HREF="JSF-186_c.html">There shall be no unreachable code in &quot;if/else/while/for&quot; block [JSF-186_c-2]</A>
<LI><A HREF="JSF-186_d.html">There shall be no unreachable code in switch statement [JSF-186_d-2]</A>
<LI><A HREF="JSF-186_e.html">There shall be no unreachable code in 'for' loop [JSF-186_e-2]</A>
<LI><A HREF="JSF-186_f.html">There shall be no unreachable code after 'if' or 'switch' statement [JSF-186_f-2]</A>
<LI><A HREF="JSF-186_g.html">There shall be no unreachable code after &quot;if&quot; or &quot;switch&quot; statement inside while/for/do...while loop [JSF-186_g-2]</A>
<LI><A HREF="JSF-187.html">All non-null statements shall either have at least one side-effect however executed or cause control flow to change [JSF-187-2]</A>
<LI><A HREF="JSF-188.html">Do not use labels [JSF-188-3]</A>
<LI><A HREF="JSF-189.html">The goto statement shall not be used [JSF-189-3]</A>
<LI><A HREF="JSF-19.html">Do not use locale.h header and setlocale function [JSF-19-2]</A>
<LI><A HREF="JSF-190.html">The continue statement shall not be used [JSF-190-2]</A>
<LI><A HREF="JSF-191.html">Do not use the break statement [JSF-191-2]</A>
<LI><A HREF="JSF-192.html">All if ... else if constructs shall be terminated with an else clause [JSF-192-3]</A>
<LI><A HREF="JSF-193.html">An unconditional break statement shall terminate every non-empty switch clause [JSF-193-2]</A>
<LI><A HREF="JSF-194.html">Always provide a default branch for switch statements [JSF-194-2]</A>
<LI><A HREF="JSF-195.html">A switch expression shall not represent a value that is effectively Boolean [JSF-195-3]</A>
<LI><A HREF="JSF-196.html">Every switch statement will have at least two cases and a potential default [JSF-196-3]</A>
<LI><A HREF="JSF-197.html">Do not use floating point variables as loop counters [JSF-197-2]</A>
<LI><A HREF="JSF-198.html">The initialization expression in a for loop will perform no actions other than to initialize the value of a single for loop parameter [JSF-198-3]</A>
<LI><A HREF="JSF-199.html">The increment expression in a for loop will perform no action other than to change a single loop parameter to the next value for the loop [JSF-199-3]</A>
<LI><A HREF="JSF-20.html">The setjmp macro and the longjmp function shall not be used [JSF-20-2]</A>
<LI><A HREF="JSF-200.html">Null initialize or increment expressions in for loops will not be used; a while loop will be used instead [JSF-200-3]</A>
<LI><A HREF="JSF-201.html">Do not modify for loop counter within a body of the loop [JSF-201-2]</A>
<LI><A HREF="JSF-202.html">Floating-point expressions shall not be tested for equality or inequality [JSF-202-2]</A>
<LI><A HREF="JSF-203.html">Evaluation of constant unsigned expression should not lead to wrap-around [JSF-203-2]</A>
<LI><A HREF="JSF-204_a.html">Assert liberally to document internal assumptions and invariants [JSF-204_a-2]</A>
<LI><A HREF="JSF-204_b.html">The increment (++) and decrement (--) operators should not be mixed with other operators in an expression [JSF-204_b-2]</A>
<LI><A HREF="JSF-204_c.html">The value of an expression shall be the same under any order of evaluation that the standard permits [JSF-204_c-2]</A>
<LI><A HREF="JSF-204_d.html">The second or third operand of a ternary operator '?:' shall not contain side effects [JSF-204_d-2]</A>
<LI><A HREF="JSF-204_e.html">Don't write code that depends on the order of evaluation of function arguments [JSF-204_e-2]</A>
<LI><A HREF="JSF-205.html">Do not use the volatile keyword [JSF-205-2]</A>
<LI><A HREF="JSF-206.html">Dynamic heap memory allocation shall not be used [JSF-206-2]</A>
<LI><A HREF="JSF-207.html">Encapsulate global variables and constants, enumerated types, and typedefs in a class [JSF-207-3]</A>
<LI><A HREF="JSF-208.html">C++ exceptions shall not be used (i.e. throw, catch and try shall not be used.) [JSF-208-2]</A>
<LI><A HREF="JSF-209.html">typedefs that indicate size and signedness should be used in place of the basic types [JSF-209-2]</A>
<LI><A HREF="JSF-21.html">The signal handling facilities of signal.h shall not be used [JSF-21-2]</A>
<LI><A HREF="JSF-210.1.html">Algorithms shall not make assumptions concerning the order of allocation of nonstatic data members separated by an access specifier [JSF-210.1-2]</A>
<LI><A HREF="JSF-213_a.html">Limited dependence should be placed on C's operator precedence rules in expressions [JSF-213_a-2]</A>
<LI><A HREF="JSF-213_b.html">Limited dependence should be placed on C's operator precedence rules in expressions [JSF-213_b-2]</A>
<LI><A HREF="JSF-213_c.html">No parentheses are required for the operand of a unary operator [JSF-213_c-2]</A>
<LI><A HREF="JSF-213_d.html">Limited dependence should be placed on C's operator precedence rules in expressions [JSF-213_d-2]</A>
<LI><A HREF="JSF-213_e.html">Use parentheses unless all operators in the expression are the same [JSF-213_e-2]</A>
<LI><A HREF="JSF-214.html">Avoid initialization order problems across translation units [JSF-214-2]</A>
<LI><A HREF="JSF-215.html">Avoid pointer arithmetic [JSF-215-3]</A>
<LI><A HREF="JSF-22.html">The input/output library stdio.h shall not be used [JSF-22-2]</A>
<LI><A HREF="JSF-23.html">The library functions atof, atoi and atol from library stdlib.h shall not be used [JSF-23-2]</A>
<LI><A HREF="JSF-24.html">The library functions abort, exit, getenv and system from library stdlib.h shall not be used [JSF-24-2]</A>
<LI><A HREF="JSF-25.html">The time handling functions of library time.h shall not be used [JSF-25-2]</A>
<LI><A HREF="JSF-26.html">Only the following pre-processor directives shall be used: #ifndef, #define, #endif, #include [JSF-26-2]</A>
<LI><A HREF="JSF-27.html">Use multiple include guards [JSF-27-3]</A>
<LI><A HREF="JSF-28.html">The #ifndef and #endif pre-processor directives will only be used to prevent multiple inclusions of the same header file [JSF-28-3]</A>
<LI><A HREF="JSF-29.html">A function should be used in preference to a function-like macro [JSF-29-2]</A>
<LI><A HREF="JSF-3.html">Follow the Cyclomatic Complexity limit of 20 [JSF-3-2]</A>
<LI><A HREF="JSF-30.html">Do not define constants via #define [JSF-30-2]</A>
<LI><A HREF="JSF-31.html">Avoid macros [JSF-31-3]</A>
<LI><A HREF="JSF-32.html">The #include pre-processor directive will only be used to include header (*.h) files [JSF-32-3]</A>
<LI><A HREF="JSF-33.html">The #include directive shall use the &lt;filename.h&gt; notation to include header files [JSF-33-2]</A>
<LI><A HREF="JSF-35.html">Use mechanism that prevents multiple inclusion of the file i.e. include guards or &quot;#pragma once&quot; preprocessor directive [JSF-35-3]</A>
<LI><A HREF="JSF-39_a.html">Don't define entities with linkage in a header file [JSF-39_a-3]</A>
<LI><A HREF="JSF-41.html">Source lines will be kept to a length of 120 characters or less [JSF-41-3]</A>
<LI><A HREF="JSF-42.html">Only one statement shall be allowed per line [JSF-42-3]</A>
<LI><A HREF="JSF-43.html">Tabs that do not use ASCII spaces shall not be used [JSF-43-4]</A>
<LI><A HREF="JSF-46.html">User-specified identifiers (internal and external) will not rely on significance of more than 64 characters [JSF-46-2]</A>
<LI><A HREF="JSF-47.html">Do not use identifiers which begin with one or two underscores (`_' or `__') [JSF-47-3]</A>
<LI><A HREF="JSF-48.html">Identifiers will not differ by mixture of case, the underscore character, interchange of the similarly looking letters and numbers [JSF-48-3]</A>
<LI><A HREF="JSF-50.html">Only the first word of the name of a class, structure, namespace, enumeration, or typedef will begin with an uppercase letter [JSF-50-3]</A>
<LI><A HREF="JSF-51.html">All letters contained in function and variable names will be composed entirely of lowercase letters [JSF-51-3]</A>
<LI><A HREF="JSF-52.html">Identifiers for constant and enumerator values shall be lowercase [JSF-52-2]</A>
<LI><A HREF="JSF-53.html">Header files will always have a file name extension of &quot;.h&quot; [JSF-53-3]</A>
<LI><A HREF="JSF-53.1.html">The following character sequences shall not appear in header file names: ', \, /*, //, or &quot; [JSF-53.1-2]</A>
<LI><A HREF="JSF-54.html">Implementation files will always have a file name extension of &quot;.cpp&quot; [JSF-54-3]</A>
<LI><A HREF="JSF-57_a.html">Order of scopes in class: public before all others [JSF-57_a-3]</A>
<LI><A HREF="JSF-57_b.html">Order of scopes in classes: protected before private [JSF-57_b-3]</A>
<LI><A HREF="JSF-58.html">When declaring functions with more than 2 parameters, the leading parenthesis and the first argument are to be written on the same line as the function name, each additional argument will be written on a separate line [JSF-58-3]</A>
<LI><A HREF="JSF-59_a.html">The statement forming the body of a 'switch', 'while', 'do...while' or 'for' statement shall be a compound statement [JSF-59_a-2]</A>
<LI><A HREF="JSF-59_b.html">'if' and 'else' should be followed by a compound statement [JSF-59_b-2]</A>
<LI><A HREF="JSF-61.html">Closing curly brace '}' shall appear on a line by themselves [JSF-61-3]</A>
<LI><A HREF="JSF-62.html">The dereference operator `*' and the address-of operator `&amp;' should be directly connected with the type names [JSF-62-3]</A>
<LI><A HREF="JSF-63_a.html">There shall be no white space following a primary operator [JSF-63_a-3]</A>
<LI><A HREF="JSF-63_b.html">There shall be no white space preceding a primary operator [JSF-63_b-3]</A>
<LI><A HREF="JSF-63_c.html">There shall be no white space between a prefix unary operator and its operand [JSF-63_c-3]</A>
<LI><A HREF="JSF-63_d.html">There shall be no white space between a postfix unary operator and its operand [JSF-63_d-3]</A>
<LI><A HREF="JSF-67_a.html">Avoid &quot;public&quot; data members [JSF-67_a-2]</A>
<LI><A HREF="JSF-67_b.html">Avoid 'protected' data members [JSF-67_b-2]</A>
<LI><A HREF="JSF-68.html">Declare the copy constructor and copy assignment operator private not in class itself, but in a specifically designed base class [JSF-68-2]</A>
<LI><A HREF="JSF-69.html">Member functions shall be declared const whenever possible [JSF-69-3]</A>
<LI><A HREF="JSF-70.1.html">Freed memory shouldn't be accessed under any circumstances. Destructor should not be called manually [JSF-70.1-2]</A>
<LI><A HREF="JSF-71.html">Public and protected methods should not be invoked by class constructor [JSF-71-2]</A>
<LI><A HREF="JSF-71.1.html">Avoid calling virtual functions from constructors and destructors [JSF-71.1-2]</A>
<LI><A HREF="JSF-74.html">Prefer initialization to assignment in constructors [JSF-74-3]</A>
<LI><A HREF="JSF-75.html">List members in an initialization list in the order in which they are declared [JSF-75-2]</A>
<LI><A HREF="JSF-76_a.html">Declare an assignment operator for classes with dynamically allocated memory [JSF-76_a-2]</A>
<LI><A HREF="JSF-76_b.html">Declare a copy constructor for classes with dynamically allocated memory [JSF-76_b-2]</A>
<LI><A HREF="JSF-77.html">A copy constructor shall copy all data members and bases [JSF-77-2]</A>
<LI><A HREF="JSF-77.1.html">The definition of a constructor shall not contain default arguments that produce a signature identical to that of the implicitly-declared copy constructor [JSF-77.1-2]</A>
<LI><A HREF="JSF-78.html">Define a virtual destructor in classes used as base classes which have virtual functions [JSF-78-2]</A>
<LI><A HREF="JSF-79.html">Call fclose() on pointer member in destructor if the pointer was used to open a file [JSF-79-2]</A>
<LI><A HREF="JSF-81.html">Check for assignment to self in operator= [JSF-81-2]</A>
<LI><A HREF="JSF-82.html">Have assignment operator returns a reference to *this; make assignment operator's return type a non-const reference to it's class' type [JSF-82-2]</A>
<LI><A HREF="JSF-83.html">The assignment operator must assign all members, including those in base classes [JSF-83-2]</A>
<LI><A HREF="JSF-85.html">When two operators are opposites (such as == and !=), it is appropriate to define both [JSF-85-3]</A>
<LI><A HREF="JSF-87.html">Hierarchies should be based on abstract classes [JSF-87-4]</A>
<LI><A HREF="JSF-88.1.html">A stateful virtual base shall be explicitly declared in each derived class that accesses it [JSF-88.1-2]</A>
<LI><A HREF="JSF-89.html">A base class shall not be both virtual and non-virtual in the same hierarchy [JSF-89-2]</A>
<LI><A HREF="JSF-9.html">Only use characters defined in ISO C standard [JSF-9-3]</A>
<LI><A HREF="JSF-94_a.html">Never redefine an inherited nonvirtual function [JSF-94_a-2]</A>
<LI><A HREF="JSF-94_b.html">Do not redefine an inherited nonvirtual function with template parameter [JSF-94_b-2]</A>
<LI><A HREF="JSF-95.html">Do not redefine an inherited virtual function with a different default parameter value [JSF-95-2]</A>
<LI><A HREF="JSF-96.html">Don't treat arrays polymorphically [JSF-96-2]</A>
<LI><A HREF="JSF-97.html">Arrays shall not be used in interfaces [JSF-97-2]</A>
<LI><A HREF="JSF-98.html">Avoid using global variables, global functions, and class in file outside namespaces [JSF-98-4]</A>
<LI><A HREF="JSF-99.html">Namespaces will not be nested more than two levels deep [JSF-99-3]</A>
</UL>
<LI><B><A HREF="METRICS.html">Metrics [METRICS]</A></B>
<UL>
<LI><A HREF="METRICS-01.html">Avoid functions with over 50 lines [METRICS-01-5]</A>
<LI><A HREF="METRICS-02.html">Avoid switch statements with many cases [METRICS-02-5]</A>
<LI><A HREF="METRICS-03.html">Number of blocks of code in a function [METRICS-03-3]</A>
<LI><A HREF="METRICS-04.html">Number of function calls within function [METRICS-04-3]</A>
<LI><A HREF="METRICS-05.html">Class inheritance level [METRICS-05-3]</A>
<LI><A HREF="METRICS-06.html">Number of data member(s) per class should not exceed 15 [METRICS-06-3]</A>
<LI><A HREF="METRICS-07.html">Number of methods per class [METRICS-07-3]</A>
<LI><A HREF="METRICS-08.html">Number of parameter(s) per method should not exceed 10 [METRICS-08-3]</A>
<LI><A HREF="METRICS-09.html">Number of private data member(s) per class [METRICS-09-3]</A>
<LI><A HREF="METRICS-10.html">Number of private methods per class [METRICS-10-3]</A>
<LI><A HREF="METRICS-11.html">Number of protected data member(s) per class [METRICS-11-3]</A>
<LI><A HREF="METRICS-12.html">Number of protected methods per class [METRICS-12-3]</A>
<LI><A HREF="METRICS-13.html">Number of public data member(s) per class [METRICS-13-3]</A>
<LI><A HREF="METRICS-14.html">Number of public methods per class [METRICS-14-3]</A>
<LI><A HREF="METRICS-15.html">Avoid functions with more than 5 parameters [METRICS-15-3]</A>
<LI><A HREF="METRICS-16.html">Macros should not use more than 5 parameters [METRICS-16-3]</A>
<LI><A HREF="METRICS-17.html">Avoid structs, unions, or classes with more than 20 fields [METRICS-17-5]</A>
<LI><A HREF="METRICS-18.html">Follow the Cyclomatic Complexity limit of 10 [METRICS-18-3]</A>
<LI><A HREF="METRICS-19.html">The percentage of comment lines versus the total number of module lines should be between 20 and 60 [METRICS-19-3]</A>
<LI><A HREF="METRICS-20.html">Avoid too long functions (declarations and statements) [METRICS-20-3]</A>
<LI><A HREF="METRICS-21.html">Avoid too long functions (blocks) [METRICS-21-3]</A>
<LI><A HREF="METRICS-22.html">Avoid functions with over 75 lines of code [METRICS-22-3]</A>
<LI><A HREF="METRICS-23.html">Avoid deep nesting [METRICS-23-3]</A>
<LI><A HREF="METRICS-24.html">Avoid source files that are longer than 500 lines [METRICS-24-5]</A>
<LI><A HREF="METRICS-25.html">Any one function (or method) will contain no more than 200 logical source lines of code (L-SLOCs) [METRICS-25-3]</A>
<LI><A HREF="METRICS-26.html">Source lines will be kept to a length of 120 characters or less [METRICS-26-3]</A>
<LI><A HREF="METRICS-27.html">Functions with more than 7 parameters will not be used [METRICS-27-3]</A>
<LI><A HREF="METRICS-28.html">Follow the Cyclomatic Complexity limit of 20 [METRICS-28-3]</A>
<LI><A HREF="METRICS-29.html">Report Cyclomatic Complexity [METRICS-29-5]</A>
<LI><A HREF="METRICS-30.html">No function should be longer than 60 lines of code [METRICS-30-3]</A>
<LI><A HREF="METRICS-31.html">The assertion density of the code should average to a minimum of two assertions per function [METRICS-31-3]</A>
<LI><A HREF="METRICS-32.html">All functions with more than 20 lines should contain at least 2 assertions [METRICS-32-3]</A>
<LI><A HREF="METRICS-33.html">Report Essential Complexity [METRICS-33-5]</A>
<LI><A HREF="METRICS-34.html">Follow the Essential Complexity limit of 4 [METRICS-34-5]</A>
<LI><A HREF="METRICS-35.html">Follow the Essential Complexity limit of 10 [METRICS-35-5]</A>
<LI><A HREF="METRICS-36.html">A function should not be called from more than 5 different functions [METRICS-36-3]</A>
<LI><A HREF="METRICS-37.html">A function should not call more than 7 different functions [METRICS-37-3]</A>
<LI><A HREF="METRICS-38.html">The number of statements within function should be in range 1 - 50 [METRICS-38-3]</A>
<LI><A HREF="METRICS-39.html">The value of VOCF metric for a function should not be higher than 4 [METRICS-39-3]</A>
<LI><A HREF="METRICS-40.html">Statements within function should not be nested deeper than 4 levels [METRICS-40-3]</A>
<LI><A HREF="METRICS-41.html">The number of blocks of comments before and inside function to the number of statements in function should be &gt; 0.2 [METRICS-41-3]</A>
</UL>
<LI><B><A HREF="MISRA.html">MISRA C [MISRA]</A></B>
<UL>
<LI><A HREF="MISRA-004_a.html">Provisions should be made for appropriate run-time checking [MISRA-004_a-5]</A>
<LI><A HREF="MISRA-004_b.html">Provisions should be made for appropriate run-time checking [MISRA-004_b-5]</A>
<LI><A HREF="MISRA-005.html">Only use characters defined in ISO C standard [MISRA-005-3]</A>
<LI><A HREF="MISRA-006.html">Values of character types shall be restricted to a defined and documented subset of ISO 10646-1 [MISRA-006-3]</A>
<LI><A HREF="MISRA-008.html">Do not use wide string literals [MISRA-008-3]</A>
<LI><A HREF="MISRA-014.html">Explicitly declare char type as signed or unsigned [MISRA-014-3]</A>
<LI><A HREF="MISRA-016.html">The underlying bit representations of floating point numbers shall not be used [MISRA-016-3]</A>
<LI><A HREF="MISRA-018_a.html">Use type suffix for numeric constants [MISRA-018_a-5]</A>
<LI><A HREF="MISRA-018_b.html">Use type suffix for numeric constants [MISRA-018_b-5]</A>
<LI><A HREF="MISRA-018_c.html">Use type suffix for numeric constants [MISRA-018_c-5]</A>
<LI><A HREF="MISRA-018_d.html">Use type suffix for numeric constants [MISRA-018_d-5]</A>
<LI><A HREF="MISRA-020.html">All functions shall be declared before use [MISRA-020-3]</A>
<LI><A HREF="MISRA-022.html">Declare objects at function scope [MISRA-022-5]</A>
<LI><A HREF="MISRA-023.html">Make declarations at file scope static where possible [MISRA-023-5]</A>
<LI><A HREF="MISRA-024.html">Use consistent linkage for identifiers [MISRA-024-3]</A>
<LI><A HREF="MISRA-027.html">External object should not be declared in more than one file [MISRA-027-3]</A>
<LI><A HREF="MISRA-028.html">Do not use register storage class [MISRA-028-5]</A>
<LI><A HREF="MISRA-029.html">The use of a tag shall agree with its declaration [MISRA-029-3]</A>
<LI><A HREF="MISRA-030.html">All automatic variables shall have been assigned a value before being used [MISRA-030-3]</A>
<LI><A HREF="MISRA-038.html">Invalid range of the right hand operand of a shift operator [MISRA-038-3]</A>
<LI><A HREF="MISRA-041.html">Document integer division [MISRA-041-5]</A>
<LI><A HREF="MISRA-042.html">The comma operator shall not be used, except in the control expression of a for loop [MISRA-042-3]</A>
<LI><A HREF="MISRA-043.html">Implicit conversions which may result in a loss of information shall not be used [MISRA-043-3]</A>
<LI><A HREF="MISRA-046_a.html">Do not use the volatile keyword [MISRA-046_a-3]</A>
<LI><A HREF="MISRA-046_c.html">Evaluation order of an expression is implementation dependent [MISRA-046_c-3]</A>
<LI><A HREF="MISRA-046_d.html">Evaluation order of an expression is implementation dependent [MISRA-046_d-3]</A>
<LI><A HREF="MISRA-048_a.html">Use explicit casts in mixed precision arithmetic [MISRA-048_a-5]</A>
<LI><A HREF="MISRA-048_b.html">Use explicit casts in mixed precision arithmetic [MISRA-048_b-5]</A>
<LI><A HREF="MISRA-048_c.html">Use explicit casts in mixed precision arithmetic [MISRA-048_c-5]</A>
<LI><A HREF="MISRA-048_d.html">Use explicit casts in mixed precision arithmetic [MISRA-048_d-5]</A>
<LI><A HREF="MISRA-048_e.html">Use explicit type conversions for arithmetic using signed and unsigned values [MISRA-048_e-3]</A>
<LI><A HREF="MISRA-051.html">Evaluation of constant unsigned expression should not lead to wrap-around [MISRA-051-5]</A>
<LI><A HREF="MISRA-054.html">A null statement shall only occur on a line by itself, and shall not &nbsp;have any other text on the same line [MISRA-054-3]</A>
<LI><A HREF="MISRA-055.html">Do not use labels [MISRA-055-5]</A>
<LI><A HREF="MISRA-058.html">Do not use the break statement [MISRA-058-3]</A>
<LI><A HREF="MISRA-065.html">Do not use floating point variables as loop counters [MISRA-065-3]</A>
<LI><A HREF="MISRA-069.html">Do not use functions with variable numbers of arguments [MISRA-069-3]</A>
<LI><A HREF="MISRA-071.html">Functions shall always have visible prototype at both the function definition and call [MISRA-071-3]</A>
<LI><A HREF="MISRA-073.html">Provide none or all identifiers for function arguments [MISRA-073-3]</A>
<LI><A HREF="MISRA-083.html">Provide expression for return statement of non-void functions [MISRA-083-3]</A>
<LI><A HREF="MISRA-084.html">Avoid expressions in return statements of void functions [MISRA-084-3]</A>
<LI><A HREF="MISRA-085.html">Use empty parentheses when calling function with no arguments [MISRA-085-5]</A>
<LI><A HREF="MISRA-086.html">If a function return error information, then that error information should be tested [MISRA-086-5]</A>
<LI><A HREF="MISRA-089.html">#include directive must be followed by a filename in double-quotes or angle brackets [MISRA-089-3]</A>
<LI><A HREF="MISRA-096.html">Enclose in parentheses whole definition of a function-like macro [MISRA-096-3]</A>
<LI><A HREF="MISRA-100.html">Use only non-ambiguous forms of defined pre-processor operator [MISRA-100-3]</A>
<LI><A HREF="MISRA-101.html">Avoid pointer arithmetic [MISRA-101-5]</A>
<LI><A HREF="MISRA-104.html">Do not use non-constant pointers to functions [MISRA-104-3]</A>
<LI><A HREF="MISRA-105.html">All the functions pointed to by a single pointer to function shall be identical in the number and type of parameters and the return type [MISRA-105-3]</A>
<LI><A HREF="MISRA-107_a.html">The NULL pointer shall not be dereferenced [MISRA-107_a-3]</A>
<LI><A HREF="MISRA-107_b.html">The NULL pointer shall not be dereferenced [MISRA-107_b-3]</A>
<LI><A HREF="MISRA-108.html">All members of structure or union should be fully specified [MISRA-108-3]</A>
<LI><A HREF="MISRA-110.html">Unions shall not be used to access the sub-parts of larger data structure [MISRA-110-3]</A>
<LI><A HREF="MISRA-113.html">All the members of a structure (or union) shall be named [MISRA-113-3]</A>
<LI><A HREF="MISRA-115.html">Standard library function names shall not be reused [MISRA-115-3]</A>
<LI><A HREF="MISRA-121_a.html">Do not use locale.h header and setlocale function [MISRA-121_a-3]</A>
<LI><A HREF="MISRA-121_b.html">Do not use locale.h header and setlocale function [MISRA-121_b-3]</A>
</UL>
<LI><B><A HREF="MISRA2004.html">MISRA C 2004 [MISRA2004]</A></B>
<UL>
<LI><A HREF="MISRA2004-10_1_a.html">Avoid implicit conversions between signed and unsigned integer types [MISRA2004-10_1_a-3]</A>
<LI><A HREF="MISRA2004-10_1_b.html">Avoid implicit conversions between integer and floating types [MISRA2004-10_1_b-3]</A>
<LI><A HREF="MISRA2004-10_1_c.html">Avoid implicit conversions of complex expressions [MISRA2004-10_1_c-3]</A>
<LI><A HREF="MISRA2004-10_1_d.html">Avoid implicit conversions from wider to narrower types [MISRA2004-10_1_d-3]</A>
<LI><A HREF="MISRA2004-10_1_e.html">Avoid implicit conversions of function return expressions [MISRA2004-10_1_e-3]</A>
<LI><A HREF="MISRA2004-10_1_f.html">Avoid implicit conversions of complex expressions [MISRA2004-10_1_f-3]</A>
<LI><A HREF="MISRA2004-10_1_g.html">Avoid implicit conversions of function arguments [MISRA2004-10_1_g-3]</A>
<LI><A HREF="MISRA2004-10_1_h.html">Avoid implicit conversions between signed and unsigned integer types [MISRA2004-10_1_h-3]</A>
<LI><A HREF="MISRA2004-10_1_i.html">Avoid implicit conversions of complex expressions [MISRA2004-10_1_i-3]</A>
<LI><A HREF="MISRA2004-10_2.html">Avoid implicit conversions of float type resulting in a loss of information [MISRA2004-10_2-3]</A>
<LI><A HREF="MISRA2004-10_2_b.html">Avoid implicit conversions of float type resulting in a loss of information [MISRA2004-10_2_b-3]</A>
<LI><A HREF="MISRA2004-10_3.html">The value of a complex expression of integer type shall only be cast to a type &nbsp;of the same signedness that is no wider than the underlying type of the expression [MISRA2004-10_3-3]</A>
<LI><A HREF="MISRA2004-10_4.html">The value of a complex expression of floating type may only be cast to a narrower floating type [MISRA2004-10_4-3]</A>
<LI><A HREF="MISRA2004-10_5.html">If the bitwise operators ~ and &lt;&lt; are applied to an operand of underlying type unsigned char or unsigned short, the result shall be immediately cast to the underlying type of the operand [MISRA2004-10_5-3]</A>
<LI><A HREF="MISRA2004-10_6.html">A &quot;U&quot; suffix shall be applied to all constants of unsigned type [MISRA2004-10_6-5]</A>
<LI><A HREF="MISRA2004-11_1.html">Conversions shall not be performed between a pointer to a function and any type other than an integral type [MISRA2004-11_1-3]</A>
<LI><A HREF="MISRA2004-11_2.html">Conversions shall not be performed between a pointer to object and any type other than an integral type, another pointer to object type or a pointer to void [MISRA2004-11_2-3]</A>
<LI><A HREF="MISRA2004-11_2_b.html">Conversions shall not be performed between a pointer to object and any type other than an integral type, another pointer to object type or a pointer to void [MISRA2004-11_2_b-3]</A>
<LI><A HREF="MISRA2004-11_2_c.html">Conversions shall not be performed between a pointer to object and any type other than an integral type, another pointer to object type or a pointer to void [MISRA2004-11_2_c-3]</A>
<LI><A HREF="MISRA2004-11_3_a.html">A cast should not convert a pointer type to an integral type [MISRA2004-11_3_a-3]</A>
<LI><A HREF="MISRA2004-11_3_b.html">A cast should not convert an integral type to a pointer type [MISRA2004-11_3_b-3]</A>
<LI><A HREF="MISRA2004-11_4.html">A cast should not be performed between a pointer to object type and a different pointer to object type [MISRA2004-11_4-3]</A>
<LI><A HREF="MISRA2004-11_5.html">A cast shall not be performed that removes any const or volatile qualification from the type addressed by a pointer [MISRA2004-11_5-3]</A>
<LI><A HREF="MISRA2004-12_10.html">The comma operator shall not be used [MISRA2004-12_10-3]</A>
<LI><A HREF="MISRA2004-12_12.html">The underlying bit representations of floating-point values shall not be used [MISRA2004-12_12-3]</A>
<LI><A HREF="MISRA2004-12_13.html">The increment (++) and decrement (--) operators should not be mixed with other operators in an expression [MISRA2004-12_13-3]</A>
<LI><A HREF="MISRA2004-12_1_a.html">Limited dependence should be placed on C's operator precedence rules in expressions [MISRA2004-12_1_a-3]</A>
<LI><A HREF="MISRA2004-12_1_b.html">Limited dependence should be placed on C's operator precedence rules in expressions [MISRA2004-12_1_b-5]</A>
<LI><A HREF="MISRA2004-12_1_c.html">No parentheses are required for the operand of a unary operator [MISRA2004-12_1_c-5]</A>
<LI><A HREF="MISRA2004-12_1_d.html">Limited dependence should be placed on C's operator precedence rules in expressions [MISRA2004-12_1_d-3]</A>
<LI><A HREF="MISRA2004-12_1_e.html">Use parentheses unless all operators in the expression are the same [MISRA2004-12_1_e-3]</A>
<LI><A HREF="MISRA2004-12_1_f.html">Limited dependence should be placed on C's operator precedence rules in expressions [MISRA2004-12_1_f-5]</A>
<LI><A HREF="MISRA2004-12_2_a.html">The value of an expression shall be the same under any order of evaluation that the standard permits [MISRA2004-12_2_a-3]</A>
<LI><A HREF="MISRA2004-12_2_b.html">Don't write code that depends on the order of evaluation of function arguments [MISRA2004-12_2_b-1]</A>
<LI><A HREF="MISRA2004-12_2_c.html">The value of an expression shall be the same under any order of evaluation that the standard permits [MISRA2004-12_2_c-3]</A>
<LI><A HREF="MISRA2004-12_2_d.html">Don't write code that depends on the order of evaluation of function calls [MISRA2004-12_2_d-3]</A>
<LI><A HREF="MISRA2004-12_2_e.html">The value of an expression shall be the same under any order of evaluation that the standard permits [MISRA2004-12_2_e-3]</A>
<LI><A HREF="MISRA2004-12_2_f.html">Do not use more than one volatile in one expression [MISRA2004-12_2_f-3]</A>
<LI><A HREF="MISRA2004-12_2_g.html">Don't write code that depends on the order of evaluation of function calls [MISRA2004-12_2_g-3]</A>
<LI><A HREF="MISRA2004-12_3.html">The sizeof operator shall not be used on expressions that contain side effects [MISRA2004-12_3-3]</A>
<LI><A HREF="MISRA2004-12_4_a.html">The right-hand operand of a logical &amp;&amp; or || operator shall not contain side effects [MISRA2004-12_4_a-3]</A>
<LI><A HREF="MISRA2004-12_4_b.html">The second or third operand of a ternary operator '?:' shall not contain side effects [MISRA2004-12_4_b-4]</A>
<LI><A HREF="MISRA2004-12_5.html">The operands of a logical &amp;&amp; or || shall be primary-expressions [MISRA2004-12_5-3]</A>
<LI><A HREF="MISRA2004-12_6_a.html">The operands of logical operators (&amp;&amp;, || and !) should be effectively Boolean [MISRA2004-12_6_a-3]</A>
<LI><A HREF="MISRA2004-12_6_b.html">Expressions that are effectively Boolean should not be used as operands to operators other than (&amp;&amp;, ||, !, =, ==, !=, ?:) [MISRA2004-12_6_b-3]</A>
<LI><A HREF="MISRA2004-12_7.html">Bitwise operators shall not be applied to operands whose underlying type is signed [MISRA2004-12_7-3]</A>
<LI><A HREF="MISRA2004-12_8.html">The right-hand operand of a shift operator shall lie between zero and one less than the width in bits of the underlying type of the left-hand operand [MISRA2004-12_8-3]</A>
<LI><A HREF="MISRA2004-12_9.html">The unary minus operator shall not be applied to an expression whose underlying type is unsigned [MISRA2004-12_9-3]</A>
<LI><A HREF="MISRA2004-13_1.html">Assignment operators shall not be used in expressions that yield a Boolean value [MISRA2004-13_1-3]</A>
<LI><A HREF="MISRA2004-13_2.html">Tests of a value against zero should be made explicit, unless the operand is effectively Boolean [MISRA2004-13_2-3]</A>
<LI><A HREF="MISRA2004-13_3.html">Floating-point expressions shall not be tested for equality or inequality [MISRA2004-13_3-3]</A>
<LI><A HREF="MISRA2004-13_4.html">The controlling expression of a for statement shall not contain any objects of floating type [MISRA2004-13_4-3]</A>
<LI><A HREF="MISRA2004-13_5.html">The three expressions of a for statement shall be concerned only with loop control [MISRA2004-13_5-3]</A>
<LI><A HREF="MISRA2004-13_6.html">Do not modify for loop counter within a body of the loop [MISRA2004-13_6-3]</A>
<LI><A HREF="MISRA2004-13_7_a.html">Boolean operations whose results are invariant shall not be permitted [MISRA2004-13_7_a-3]</A>
<LI><A HREF="MISRA2004-13_7_aa.html">Boolean operations whose results are invariant shall not be permitted [MISRA2004-13_7_aa-3]</A>
<LI><A HREF="MISRA2004-13_7_ab.html">Boolean operations whose results are invariant shall not be permitted [MISRA2004-13_7_ab-3]</A>
<LI><A HREF="MISRA2004-13_7_ac.html">Boolean operations whose results are invariant shall not be permitted [MISRA2004-13_7_ac-3]</A>
<LI><A HREF="MISRA2004-13_7_ad.html">Boolean operations whose results are invariant shall not be permitted [MISRA2004-13_7_ad-3]</A>
<LI><A HREF="MISRA2004-13_7_ae.html">Boolean operations whose results are invariant shall not be permitted [MISRA2004-13_7_ae-3]</A>
<LI><A HREF="MISRA2004-13_7_af.html">Boolean operations whose results are invariant shall not be permitted [MISRA2004-13_7_af-3]</A>
<LI><A HREF="MISRA2004-13_7_ag.html">Boolean operations whose results are invariant shall not be permitted [MISRA2004-13_7_ag-3]</A>
<LI><A HREF="MISRA2004-13_7_ah.html">Boolean operations whose results are invariant shall not be permitted [MISRA2004-13_7_ah-3]</A>
<LI><A HREF="MISRA2004-13_7_ai.html">Boolean operations whose results are invariant shall not be permitted [MISRA2004-13_7_ai-3]</A>
<LI><A HREF="MISRA2004-13_7_aj.html">Boolean operations whose results are invariant shall not be permitted [MISRA2004-13_7_aj-3]</A>
<LI><A HREF="MISRA2004-13_7_ak.html">Boolean operations whose results are invariant shall not be permitted [MISRA2004-13_7_ak-3]</A>
<LI><A HREF="MISRA2004-13_7_b.html">Boolean operations whose results are invariant shall not be permitted [MISRA2004-13_7_b-3]</A>
<LI><A HREF="MISRA2004-13_7_c.html">Boolean operations whose results are invariant shall not be permitted [MISRA2004-13_7_c-3]</A>
<LI><A HREF="MISRA2004-13_7_d.html">Boolean operations whose results are invariant shall not be permitted [MISRA2004-13_7_d-3]</A>
<LI><A HREF="MISRA2004-13_7_j.html">Boolean operations whose results are invariant shall not be permitted [MISRA2004-13_7_j-3]</A>
<LI><A HREF="MISRA2004-13_7_k.html">Boolean operations whose results are invariant shall not be permitted [MISRA2004-13_7_k-3]</A>
<LI><A HREF="MISRA2004-13_7_l.html">Boolean operations whose results are invariant shall not be permitted [MISRA2004-13_7_l-3]</A>
<LI><A HREF="MISRA2004-13_7_m.html">Boolean operations whose results are invariant shall not be permitted [MISRA2004-13_7_m-3]</A>
<LI><A HREF="MISRA2004-13_7_n.html">Boolean operations whose results are invariant shall not be permitted [MISRA2004-13_7_n-3]</A>
<LI><A HREF="MISRA2004-13_7_s.html">Boolean operations whose results are invariant shall not be permitted [MISRA2004-13_7_s-3]</A>
<LI><A HREF="MISRA2004-13_7_t.html">Boolean operations whose results are invariant shall not be permitted [MISRA2004-13_7_t-3]</A>
<LI><A HREF="MISRA2004-13_7_u.html">Boolean operations whose results are invariant shall not be permitted [MISRA2004-13_7_u-3]</A>
<LI><A HREF="MISRA2004-13_7_v.html">Boolean operations whose results are invariant shall not be permitted [MISRA2004-13_7_v-3]</A>
<LI><A HREF="MISRA2004-13_7_w.html">Boolean operations whose results are invariant shall not be permitted [MISRA2004-13_7_w-3]</A>
<LI><A HREF="MISRA2004-13_7_x.html">Boolean operations whose results are invariant shall not be permitted [MISRA2004-13_7_x-3]</A>
<LI><A HREF="MISRA2004-13_7_y.html">Boolean operations whose results are invariant shall not be permitted [MISRA2004-13_7_y-3]</A>
<LI><A HREF="MISRA2004-13_7_z.html">Boolean operations whose results are invariant shall not be permitted [MISRA2004-13_7_z-3]</A>
<LI><A HREF="MISRA2004-14_10.html">All if ... else if constructs shall be terminated with an else clause [MISRA2004-14_10-3]</A>
<LI><A HREF="MISRA2004-14_1_a.html">There shall be no unreachable code in &quot;else&quot; block [MISRA2004-14_1_a-3]</A>
<LI><A HREF="MISRA2004-14_1_b.html">There shall be no unreachable code after 'return', 'break', 'continue', and 'goto' statements [MISRA2004-14_1_b-3]</A>
<LI><A HREF="MISRA2004-14_1_c.html">There shall be no unreachable code in &quot;if/else/while/for&quot; block [MISRA2004-14_1_c-3]</A>
<LI><A HREF="MISRA2004-14_1_d.html">There shall be no unreachable code in switch statement [MISRA2004-14_1_d-3]</A>
<LI><A HREF="MISRA2004-14_1_e.html">There shall be no unreachable code in 'for' loop [MISRA2004-14_1_e-3]</A>
<LI><A HREF="MISRA2004-14_1_f.html">There shall be no unreachable code after 'if' or 'switch' statement [MISRA2004-14_1_f-3]</A>
<LI><A HREF="MISRA2004-14_1_g.html">There shall be no unreachable code after &quot;if&quot; or &quot;switch&quot; statement inside while/for/do...while loop [MISRA2004-14_1_g-3]</A>
<LI><A HREF="MISRA2004-14_2.html">All non-null statements shall either have at least one side-effect however executed or cause control flow to change [MISRA2004-14_2-3]</A>
<LI><A HREF="MISRA2004-14_3.html">Null statement shall only occur on a line by itself or it may be followed by a comment [MISRA2004-14_3-3]</A>
<LI><A HREF="MISRA2004-14_4.html">The goto statement shall not be used [MISRA2004-14_4-3]</A>
<LI><A HREF="MISRA2004-14_5.html">The continue statement shall not be used [MISRA2004-14_5-3]</A>
<LI><A HREF="MISRA2004-14_6.html">For any iteration statement there shall be at most one break statement used for loop termination [MISRA2004-14_6-3]</A>
<LI><A HREF="MISRA2004-14_7.html">A function shall have a single point of exit at the end of the function [MISRA2004-14_7-3]</A>
<LI><A HREF="MISRA2004-14_8.html">The statement forming the body of a 'switch', 'while', 'do...while' or 'for' statement shall be a compound statement [MISRA2004-14_8-3]</A>
<LI><A HREF="MISRA2004-14_9.html">'if' and 'else' should be followed by a compound statement [MISRA2004-14_9-3]</A>
<LI><A HREF="MISRA2004-15_0_a.html">A switch statement shall only contain switch labels and switch clauses, and no other code [MISRA2004-15_0_a-3]</A>
<LI><A HREF="MISRA2004-15_0_b.html">A switch statement shall only contain switch labels and switch clauses, and no other code [MISRA2004-15_0_b-3]</A>
<LI><A HREF="MISRA2004-15_0_c.html">A switch statement shall only contain switch labels and switch clauses, and no other code [MISRA2004-15_0_c-3]</A>
<LI><A HREF="MISRA2004-15_1.html">A switch label shall only be used when the most closely-enclosing compound statement is the body of a switch statement [MISRA2004-15_1-3]</A>
<LI><A HREF="MISRA2004-15_2.html">An unconditional break statement shall terminate every non-empty switch clause [MISRA2004-15_2-3]</A>
<LI><A HREF="MISRA2004-15_3.html">The final clause of a switch statement shall be the default clause [MISRA2004-15_3-3]</A>
<LI><A HREF="MISRA2004-15_4.html">A switch expression shall not represent a value that is effectively Boolean [MISRA2004-15_4-3]</A>
<LI><A HREF="MISRA2004-15_5.html">Every switch statement shall have at least one case clause [MISRA2004-15_5-3]</A>
<LI><A HREF="MISRA2004-16_1.html">Functions shall not be defined with a variable number of arguments [MISRA2004-16_1-3]</A>
<LI><A HREF="MISRA2004-16_10.html">If a function returns error information, then that error information shall be tested [MISRA2004-16_10-3]</A>
<LI><A HREF="MISRA2004-16_2.html">Functions shall not call themselves, either directly or indirectly [MISRA2004-16_2-3]</A>
<LI><A HREF="MISRA2004-16_3.html">Identifiers shall be given for all of the parameters in a function prototype declaration [MISRA2004-16_3-3]</A>
<LI><A HREF="MISRA2004-16_4.html">The identifiers used in the declaration and definition of a function shall be identical [MISRA2004-16_4-3]</A>
<LI><A HREF="MISRA2004-16_5.html">Functions with no parameters shall be declared with parameter type void [MISRA2004-16_5-3]</A>
<LI><A HREF="MISRA2004-16_6.html">The number of arguments passed to a function shall match the number of parameters [MISRA2004-16_6-3]</A>
<LI><A HREF="MISRA2004-16_7.html">A pointer parameter in a function prototype should be declared as pointer to const if the pointer is not used to modify the addressed object [MISRA2004-16_7-3]</A>
<LI><A HREF="MISRA2004-16_8.html">All exit paths from a function with non-void return type shall have an explicit return statement with an expression [MISRA2004-16_8-3]</A>
<LI><A HREF="MISRA2004-17_1.html">Pointer arithmetic shall only be applied to pointers that address an array or array element [MISRA2004-17_1-3]</A>
<LI><A HREF="MISRA2004-17_2.html">Pointer arithmetic shall only be applied to pointers that address an array or array element [MISRA2004-17_2-3]</A>
<LI><A HREF="MISRA2004-17_3.html">&gt;, &gt;=, &lt;, &lt;= shall not be applied to pointer types except where they point to the same array [MISRA2004-17_3-3]</A>
<LI><A HREF="MISRA2004-17_4.html">Array indexing shall be the only allowed form of pointer arithmetic [MISRA2004-17_4-3]</A>
<LI><A HREF="MISRA2004-17_5_a.html">The declaration of objects should contain no more than 2 levels of pointer indirection [MISRA2004-17_5_a-3]</A>
<LI><A HREF="MISRA2004-17_5_b.html">The declaration of objects should contain no more than 2 levels of pointer indirection [MISRA2004-17_5_b-3]</A>
<LI><A HREF="MISRA2004-17_5_c.html">The declaration of objects should contain no more than 2 levels of pointer indirection [MISRA2004-17_5_c-3]</A>
<LI><A HREF="MISRA2004-17_5_d.html">The declaration of objects should contain no more than 2 levels of pointer indirection [MISRA2004-17_5_d-3]</A>
<LI><A HREF="MISRA2004-17_6.html">The address of an object with automatic storage shall not be assigned to another object that may persist after the first object has ceased to exist [MISRA2004-17_6-3]</A>
<LI><A HREF="MISRA2004-18_1.html">All structure and union types shall be complete at the end of a translation unit [MISRA2004-18_1-3]</A>
<LI><A HREF="MISRA2004-18_2.html">An object shall not be assigned to an overlapping object [MISRA2004-18_2-3]</A>
<LI><A HREF="MISRA2004-18_2_b.html">An object shall not be assigned to an overlapping object [MISRA2004-18_2_b-3]</A>
<LI><A HREF="MISRA2004-18_4.html">Unions shall not be used [MISRA2004-18_4-3]</A>
<LI><A HREF="MISRA2004-19_1.html">#include statements in a file should only be preceded by other preprocessor directives or comments [MISRA2004-19_1-3]</A>
<LI><A HREF="MISRA2004-19_10.html">In the definition of a function-like macro each instance of a parameter shall be enclosed in parentheses unless it is used as the operand of # or ## [MISRA2004-19_10-3]</A>
<LI><A HREF="MISRA2004-19_11.html">All macro identifiers in preprocessor directives shall be defined before use, except in #ifdef and #ifndef preprocessor directives and the defined() operator [MISRA2004-19_11-3]</A>
<LI><A HREF="MISRA2004-19_12.html">There shall be at most one occurrence of the # or ## preprocessor operators in a single macro definition [MISRA2004-19_12-3]</A>
<LI><A HREF="MISRA2004-19_13.html">The # and ## preprocessor operators should not be used [MISRA2004-19_13-3]</A>
<LI><A HREF="MISRA2004-19_14.html">The defined preprocessor operator shall only be used in one of the two standard forms [MISRA2004-19_14-3]</A>
<LI><A HREF="MISRA2004-19_15.html">Precautions shall be taken in order to prevent the contents of a header file being included twice [MISRA2004-19_15-3]</A>
<LI><A HREF="MISRA2004-19_16.html">Preprocessing directives shall be syntactically meaningful even when excluded by the preprocessor [MISRA2004-19_16-3]</A>
<LI><A HREF="MISRA2004-19_17.html">All #else, #elif and #endif preprocessor directives shall reside in the same file as the #if or #ifdef directive to which they are related [MISRA2004-19_17-3]</A>
<LI><A HREF="MISRA2004-19_2.html">Non-standard characters should not occur in header file names in #include directives [MISRA2004-19_2-3]</A>
<LI><A HREF="MISRA2004-19_4.html">Avoid keywords and basic types in macros [MISRA2004-19_4-3]</A>
<LI><A HREF="MISRA2004-19_5.html">Macros shall not be #define'd or #undef'd within a block [MISRA2004-19_5-3]</A>
<LI><A HREF="MISRA2004-19_6.html">#undef shall not be used [MISRA2004-19_6-3]</A>
<LI><A HREF="MISRA2004-19_7.html">A function should be used in preference to a function-like macro [MISRA2004-19_7-3]</A>
<LI><A HREF="MISRA2004-19_8.html">A function-like macro shall not be invoked without all of its arguments [MISRA2004-19_8-3]</A>
<LI><A HREF="MISRA2004-19_9.html">Arguments to a function-like macro shall not contain tokens that look like preprocessing directives [MISRA2004-19_9-3]</A>
<LI><A HREF="MISRA2004-20_10.html">The library functions atof, atoi and atol from library stdlib.h shall not be used [MISRA2004-20_10-3]</A>
<LI><A HREF="MISRA2004-20_11.html">The library functions abort, exit, getenv and system from library stdlib.h shall not be used [MISRA2004-20_11-3]</A>
<LI><A HREF="MISRA2004-20_12.html">The time handling functions of library time.h shall not be used [MISRA2004-20_12-3]</A>
<LI><A HREF="MISRA2004-20_1_a.html">Reserved identifiers, macros and functions in the standard library, shall not be defined, redefined or undefined [MISRA2004-20_1_a-3]</A>
<LI><A HREF="MISRA2004-20_1_b.html">Do not redefine reserved words [MISRA2004-20_1_b-3]</A>
<LI><A HREF="MISRA2004-20_2.html">The names of standard library macros, objects and functions shall not be reused [MISRA2004-20_2-3]</A>
<LI><A HREF="MISRA2004-20_3.html">The validity of values passed to library functions shall be checked [MISRA2004-20_3-3]</A>
<LI><A HREF="MISRA2004-20_4.html">Dynamic heap memory allocation shall not be used [MISRA2004-20_4-3]</A>
<LI><A HREF="MISRA2004-20_5.html">The error indicator errno shall not be used [MISRA2004-20_5-3]</A>
<LI><A HREF="MISRA2004-20_6.html">The macro offsetof, in library stddef.h, shall not be used [MISRA2004-20_6-3]</A>
<LI><A HREF="MISRA2004-20_7.html">The setjmp macro and the longjmp function shall not be used [MISRA2004-20_7-3]</A>
<LI><A HREF="MISRA2004-20_8.html">The signal handling facilities of signal.h shall not be used [MISRA2004-20_8-3]</A>
<LI><A HREF="MISRA2004-20_9.html">The input/output library stdio.h shall not be used [MISRA2004-20_9-3]</A>
<LI><A HREF="MISRA2004-2_1.html">Assembly language shall be encapsulated and isolated [MISRA2004-2_1-3]</A>
<LI><A HREF="MISRA2004-2_2.html">Source code shall only use /* ... */ style comments [MISRA2004-2_2-3]</A>
<LI><A HREF="MISRA2004-2_3.html">The character sequence /* shall not be used within a comment [MISRA2004-2_3-3]</A>
<LI><A HREF="MISRA2004-2_4.html">Sections of code should not be &quot;commented out&quot; [MISRA2004-2_4-4]</A>
<LI><A HREF="MISRA2004-3_4.html">All uses of the #pragma directive shall be documented and explained [MISRA2004-3_4-3]</A>
<LI><A HREF="MISRA2004-3_5.html">Do not mix bit-fields and other data within the same structure [MISRA2004-3_5-3]</A>
<LI><A HREF="MISRA2004-4_1.html">Only those escape sequences that are defined in the ISO C standard shall be used [MISRA2004-4_1-3]</A>
<LI><A HREF="MISRA2004-4_2.html">Trigraphs shall not be used [MISRA2004-4_2-3]</A>
<LI><A HREF="MISRA2004-5_1.html">Identifiers (internal and external) shall not rely on the significance of more than 31 characters [MISRA2004-5_1-3]</A>
<LI><A HREF="MISRA2004-5_2_a.html">Identifiers in an inner scope shall not use the same name as an identifier in an outer scope, and therefore hide that identifier [MISRA2004-5_2_a-3]</A>
<LI><A HREF="MISRA2004-5_2_b.html">Identifiers in an inner scope shall not use the same name as an identifier in an outer scope, and therefore hide that identifier [MISRA2004-5_2_b-3]</A>
<LI><A HREF="MISRA2004-5_3_a.html">Do not reuse typedef names [MISRA2004-5_3_a-3]</A>
<LI><A HREF="MISRA2004-5_3_b.html">Do not reuse typedef names as a typedef name [MISRA2004-5_3_b-3]</A>
<LI><A HREF="MISRA2004-5_4_a.html">A tag name shall not be reused for other purpose within the program [MISRA2004-5_4_a-3]</A>
<LI><A HREF="MISRA2004-5_4_b.html">A tag name shall not be reused to define a different tag [MISRA2004-5_4_b-3]</A>
<LI><A HREF="MISRA2004-5_5_a.html">No object or function identifier with static storage duration should be reused [MISRA2004-5_5_a-4]</A>
<LI><A HREF="MISRA2004-5_5_b.html">No object or function identifier with static storage duration should be reused [MISRA2004-5_5_b-4]</A>
<LI><A HREF="MISRA2004-5_6.html">No identifier in one name space should have the same spelling as an identifier in another name space, with the exception of structure and union member names [MISRA2004-5_6-4]</A>
<LI><A HREF="MISRA2004-5_7.html">No identifier name should be reused [MISRA2004-5_7-4]</A>
<LI><A HREF="MISRA2004-6_1.html">The plain char type shall be used only for the storage and use of character values [MISRA2004-6_1-3]</A>
<LI><A HREF="MISRA2004-6_2.html">signed and unsigned char type shall be used only for the storage and use of numeric values [MISRA2004-6_2-3]</A>
<LI><A HREF="MISRA2004-6_3.html">typedefs that indicate size and signedness should be used in place of the basic types [MISRA2004-6_3-3]</A>
<LI><A HREF="MISRA2004-6_4.html">Bit fields shall only be defined to be of type unsigned int or signed int [MISRA2004-6_4-3]</A>
<LI><A HREF="MISRA2004-6_5.html">Bit fields of signed types shall be at least 2 bits long [MISRA2004-6_5-3]</A>
<LI><A HREF="MISRA2004-7_1.html">Octal constants (other than zero) and octal escape sequences shall not be used [MISRA2004-7_1-3]</A>
<LI><A HREF="MISRA2004-8_11.html">The static storage class specifier shall be used in definitions and declarations of objects and functions that have internal linkage [MISRA2004-8_11-3]</A>
<LI><A HREF="MISRA2004-8_12.html">When an array is declared with external linkage, its size shall be stated explicitly or defined implicitly by initialisation [MISRA2004-8_12-3]</A>
<LI><A HREF="MISRA2004-8_2_a.html">Whenever a function is declared or defined, its type shall be explicitly stated [MISRA2004-8_2_a-3]</A>
<LI><A HREF="MISRA2004-8_2_b.html">Whenever an object is declared or defined, its type shall be explicitly stated [MISRA2004-8_2_b-3]</A>
<LI><A HREF="MISRA2004-8_3_a.html">Use identical types in declaration and definition [MISRA2004-8_3_a-3]</A>
<LI><A HREF="MISRA2004-8_3_b.html">Use identical types in declaration and definition [MISRA2004-8_3_b-3]</A>
<LI><A HREF="MISRA2004-8_5.html">There shall be no definitions of objects or functions in a header file [MISRA2004-8_5-3]</A>
<LI><A HREF="MISRA2004-8_6.html">Always declare functions at file scope [MISRA2004-8_6-3]</A>
<LI><A HREF="MISRA2004-8_7.html">Objects shall be defined at block scope if they are only accessed from within a single function [MISRA2004-8_7-3]</A>
<LI><A HREF="MISRA2004-9_2.html">Braces shall be used to indicate and match the structure in the non-zero initialization of arrays and structures [MISRA2004-9_2-3]</A>
<LI><A HREF="MISRA2004-9_3.html">In an enumerator list, the &quot;=&quot; construct shall not be used to explicitly initialise members other than the first, unless all items are explicitly initialised [MISRA2004-9_3-3]</A>
</UL>
<LI><B><A HREF="MISRA2008.html">MISRA C++ 2008 [MISRA2008]</A></B>
<UL>
<LI><A HREF="MISRA2008-0_1_10.html">Every defined function shall be called at least once [MISRA2008-0_1_10-3]</A>
<LI><A HREF="MISRA2008-0_1_11.html">There shall be no unused parameters (named or unnamed) in nonvirtual functions [MISRA2008-0_1_11-3]</A>
<LI><A HREF="MISRA2008-0_1_1_a.html">A project shall not contain unreachable code in 'else' block [MISRA2008-0_1_1_a-3]</A>
<LI><A HREF="MISRA2008-0_1_1_b.html">A project shall not contain unreachable code after 'return', 'break', 'continue', and 'goto' statements [MISRA2008-0_1_1_b-3]</A>
<LI><A HREF="MISRA2008-0_1_1_c.html">A project shall not contain unreachable code in 'if/else/while/for' block [MISRA2008-0_1_1_c-3]</A>
<LI><A HREF="MISRA2008-0_1_1_d.html">A project shall not contain unreachable code in switch statement [MISRA2008-0_1_1_d-3]</A>
<LI><A HREF="MISRA2008-0_1_1_e.html">A project shall not contain unreachable code in 'for' loop [MISRA2008-0_1_1_e-3]</A>
<LI><A HREF="MISRA2008-0_1_1_f.html">A project shall not contain unreachable code after 'if' or 'switch' statement outside 'for/while/catch' block [MISRA2008-0_1_1_f-3]</A>
<LI><A HREF="MISRA2008-0_1_1_g.html">A project shall not contain unreachable code after 'if' or 'switch' statement inside 'while/for/catch' block [MISRA2008-0_1_1_g-3]</A>
<LI><A HREF="MISRA2008-0_1_2_a.html">A project shall not contain infeasible paths [MISRA2008-0_1_2_a-3]</A>
<LI><A HREF="MISRA2008-0_1_2_b.html">A project shall not contain infeasible paths [MISRA2008-0_1_2_b-3]</A>
<LI><A HREF="MISRA2008-0_1_2_c.html">A project shall not contain infeasible paths [MISRA2008-0_1_2_c-3]</A>
<LI><A HREF="MISRA2008-0_1_2_d.html">A project shall not contain infeasible paths [MISRA2008-0_1_2_d-3]</A>
<LI><A HREF="MISRA2008-0_1_2_e.html">A project shall not contain infeasible paths [MISRA2008-0_1_2_e-3]</A>
<LI><A HREF="MISRA2008-0_1_2_f.html">A project shall not contain infeasible paths [MISRA2008-0_1_2_f-3]</A>
<LI><A HREF="MISRA2008-0_1_2_g.html">A project shall not contain infeasible paths [MISRA2008-0_1_2_g-3]</A>
<LI><A HREF="MISRA2008-0_1_2_h.html">A project shall not contain infeasible paths [MISRA2008-0_1_2_h-3]</A>
<LI><A HREF="MISRA2008-0_1_2_i.html">A project shall not contain infeasible paths [MISRA2008-0_1_2_i-3]</A>
<LI><A HREF="MISRA2008-0_1_2_j.html">A project shall not contain infeasible paths [MISRA2008-0_1_2_j-3]</A>
<LI><A HREF="MISRA2008-0_1_2_k.html">A project shall not contain infeasible paths [MISRA2008-0_1_2_k-3]</A>
<LI><A HREF="MISRA2008-0_1_2_l.html">A project shall not contain infeasible paths [MISRA2008-0_1_2_l-3]</A>
<LI><A HREF="MISRA2008-0_1_2_m.html">A project shall not contain infeasible paths [MISRA2008-0_1_2_m-3]</A>
<LI><A HREF="MISRA2008-0_1_2_n.html">A project shall not contain infeasible paths [MISRA2008-0_1_2_n-3]</A>
<LI><A HREF="MISRA2008-0_1_2_o.html">A project shall not contain infeasible paths [MISRA2008-0_1_2_o-3]</A>
<LI><A HREF="MISRA2008-0_1_2_p.html">A project shall not contain infeasible paths [MISRA2008-0_1_2_p-3]</A>
<LI><A HREF="MISRA2008-0_1_2_q.html">A project shall not contain infeasible paths [MISRA2008-0_1_2_q-3]</A>
<LI><A HREF="MISRA2008-0_1_2_r.html">A project shall not contain infeasible paths [MISRA2008-0_1_2_r-3]</A>
<LI><A HREF="MISRA2008-0_1_2_rz.html">A project shall not contain infeasible paths [MISRA2008-0_1_2_rz-3]</A>
<LI><A HREF="MISRA2008-0_1_2_s.html">A project shall not contain infeasible paths [MISRA2008-0_1_2_s-3]</A>
<LI><A HREF="MISRA2008-0_1_2_sz.html">A project shall not contain infeasible paths [MISRA2008-0_1_2_sz-3]</A>
<LI><A HREF="MISRA2008-0_1_2_t.html">A project shall not contain infeasible paths [MISRA2008-0_1_2_t-3]</A>
<LI><A HREF="MISRA2008-0_1_2_u.html">A project shall not contain infeasible paths [MISRA2008-0_1_2_u-3]</A>
<LI><A HREF="MISRA2008-0_1_2_v.html">A project shall not contain infeasible paths [MISRA2008-0_1_2_v-3]</A>
<LI><A HREF="MISRA2008-0_1_2_w.html">A project shall not contain infeasible paths [MISRA2008-0_1_2_w-3]</A>
<LI><A HREF="MISRA2008-0_1_2_x.html">A project shall not contain infeasible paths [MISRA2008-0_1_2_x-3]</A>
<LI><A HREF="MISRA2008-0_1_2_y.html">A project shall not contain infeasible paths [MISRA2008-0_1_2_y-3]</A>
<LI><A HREF="MISRA2008-0_1_2_z.html">A project shall not contain infeasible paths [MISRA2008-0_1_2_z-3]</A>
<LI><A HREF="MISRA2008-0_1_3_a.html">A project shall not contain unused variables [MISRA2008-0_1_3_a-3]</A>
<LI><A HREF="MISRA2008-0_1_3_b.html">A project shall not contain unused variables [MISRA2008-0_1_3_b-3]</A>
<LI><A HREF="MISRA2008-0_1_7.html">The value returned by a function having a non-void return type that is not an overloaded operator shall always be used [MISRA2008-0_1_7-3]</A>
<LI><A HREF="MISRA2008-0_1_8.html">All functions with void return type shall have external side effect(s) [MISRA2008-0_1_8-3]</A>
<LI><A HREF="MISRA2008-0_2_1_a.html">An object shall not be assigned to an overlapping object [MISRA2008-0_2_1_a-3]</A>
<LI><A HREF="MISRA2008-0_2_1_b.html">An object shall not be assigned to an overlapping object [MISRA2008-0_2_1_b-3]</A>
<LI><A HREF="MISRA2008-0_3_2.html">If a function generates error information, then that error information shall be tested [MISRA2008-0_3_2-3]</A>
<LI><A HREF="MISRA2008-0_4_2.html">Use of floating-point arithmetic shall be documented [MISRA2008-0_4_2-3]</A>
<LI><A HREF="MISRA2008-10_1_1.html">Classes should not be derived from virtual bases [MISRA2008-10_1_1-4]</A>
<LI><A HREF="MISRA2008-10_1_3.html">An accessible base class shall not be both virtual and non-virtual in the same hierarchy [MISRA2008-10_1_3-3]</A>
<LI><A HREF="MISRA2008-10_3_1.html">There shall be no more than one definition of each virtual function on each path through the inheritance hierarchy [MISRA2008-10_3_1-3]</A>
<LI><A HREF="MISRA2008-10_3_2.html">Each overriding virtual function shall be declared with the virtual keyword [MISRA2008-10_3_2-3]</A>
<LI><A HREF="MISRA2008-10_3_3.html">A virtual function shall only be overridden by a pure virtual function if it is itself declared as pure virtual [MISRA2008-10_3_3-3]</A>
<LI><A HREF="MISRA2008-11_0_1.html">Member data in non-POD class types shall be private [MISRA2008-11_0_1-3]</A>
<LI><A HREF="MISRA2008-12_1_1.html">An object's dynamic type shall not be used from the body of its constructor or destructor [MISRA2008-12_1_1-3]</A>
<LI><A HREF="MISRA2008-12_1_2.html">All constructors of a class should explicitly call a constructor for all of its immediate base classes and all virtual base classes [MISRA2008-12_1_2-4]</A>
<LI><A HREF="MISRA2008-12_1_3.html">All constructors that are callable with a single argument of fundamental type shall be declared explicit [MISRA2008-12_1_3-3]</A>
<LI><A HREF="MISRA2008-12_8_1.html">A copy constructor shall only initialize its base classes and the nonstatic members of the class of which it is a member [MISRA2008-12_8_1-3]</A>
<LI><A HREF="MISRA2008-12_8_2.html">The copy assignment operator shall be declared protected or private in an abstract class [MISRA2008-12_8_2-3]</A>
<LI><A HREF="MISRA2008-14_5_2.html">A copy constructor shall be declared when there is a template constructor with a single parameter that is a generic parameter [MISRA2008-14_5_2-3]</A>
<LI><A HREF="MISRA2008-14_5_3.html">A copy assignment operator shall be declared when there is a template assignment operator with a parameter that is a generic parameter [MISRA2008-14_5_3-3]</A>
<LI><A HREF="MISRA2008-14_6_1.html">In a class template with a dependent base, any name that may be found in that dependent base shall be referred to using a qualified-id or this-&gt; [MISRA2008-14_6_1-3]</A>
<LI><A HREF="MISRA2008-14_7_3.html">All partial and explicit specializations for a template shall be declared in the same file as the declaration of their primary template [MISRA2008-14_7_3-3]</A>
<LI><A HREF="MISRA2008-14_8_1.html">Overloaded function templates shall not be explicitly specialized [MISRA2008-14_8_1-3]</A>
<LI><A HREF="MISRA2008-14_8_2.html">The viable function set for a function call should either contain no function specializations, or only contain function specializations [MISRA2008-14_8_2-4]</A>
<LI><A HREF="MISRA2008-15_0_2.html">An exception object should not have pointer type [MISRA2008-15_0_2-4]</A>
<LI><A HREF="MISRA2008-15_0_3.html">Control shall not be transferred into a try or catch block using a goto or a switch statement [MISRA2008-15_0_3-3]</A>
<LI><A HREF="MISRA2008-15_1_1.html">The assignment-expression of a throw statement shall not itself cause an exception to be thrown [MISRA2008-15_1_1-3]</A>
<LI><A HREF="MISRA2008-15_1_2.html">NULL shall not be thrown explicitly [MISRA2008-15_1_2-3]</A>
<LI><A HREF="MISRA2008-15_1_3.html">An empty throw (throw;) shall only be used in the compound statement of a catch handler [MISRA2008-15_1_3-3]</A>
<LI><A HREF="MISRA2008-15_3_1.html">Exceptions shall be raised only after start-up and before termination of the program [MISRA2008-15_3_1-3]</A>
<LI><A HREF="MISRA2008-15_3_2.html">There should be at least one exception handler to catch all otherwise unhandled exceptions [MISRA2008-15_3_2-4]</A>
<LI><A HREF="MISRA2008-15_3_3.html">Handlers of a function-try-block implementation of a class constructor or destructor shall not reference non-static members from this class or its bases [MISRA2008-15_3_3-3]</A>
<LI><A HREF="MISRA2008-15_3_4_a.html">Each exception explicitly thrown in the code shall have a handler of a compatible type in all call paths that could lead to that point [MISRA2008-15_3_4_a-3]</A>
<LI><A HREF="MISRA2008-15_3_4_b.html">Each exception explicitly thrown in the code shall have a handler of a compatible type in all call paths that could lead to that point [MISRA2008-15_3_4_b-3]</A>
<LI><A HREF="MISRA2008-15_3_5.html">A class type exception shall always be caught by reference [MISRA2008-15_3_5-3]</A>
<LI><A HREF="MISRA2008-15_3_6.html">Where multiple handlers are provided in a single try-catch statement or function-try-block for a derived class and some or all of its bases, the handlers shall be ordered most-derived to base class [MISRA2008-15_3_6-3]</A>
<LI><A HREF="MISRA2008-15_5_1.html">A class destructor shall not exit with an exception [MISRA2008-15_5_1-3]</A>
<LI><A HREF="MISRA2008-15_5_2.html">Where a function's declaration includes an exception-specification, the function shall only be capable of throwing exceptions of the indicated type(s) [MISRA2008-15_5_2-3]</A>
<LI><A HREF="MISRA2008-15_5_3.html">The terminate() function shall not be called implicitly [MISRA2008-15_5_3-3]</A>
<LI><A HREF="MISRA2008-16_0_1.html">#include directives in a file shall only be preceded by other preprocessor directives or comments [MISRA2008-16_0_1-3]</A>
<LI><A HREF="MISRA2008-16_0_2.html">Macros shall only be #define'd or #undef'd in the global namespace [MISRA2008-16_0_2-3]</A>
<LI><A HREF="MISRA2008-16_0_3.html">#undef shall not be used [MISRA2008-16_0_3-3]</A>
<LI><A HREF="MISRA2008-16_0_4.html">Function-like macros shall not be defined [MISRA2008-16_0_4-3]</A>
<LI><A HREF="MISRA2008-16_0_5.html">Arguments to a function-like macro shall not contain tokens that look like preprocessing directives [MISRA2008-16_0_5-3]</A>
<LI><A HREF="MISRA2008-16_0_6.html">In the definition of a function-like macro, each instance of a parameter shall be enclosed in parentheses, unless it is used as the operand of # or ## [MISRA2008-16_0_6-3]</A>
<LI><A HREF="MISRA2008-16_0_7.html">Undefined macro identifiers shall not be used in #if or #elif preprocessor directives, except as operands to the defined operator [MISRA2008-16_0_7-3]</A>
<LI><A HREF="MISRA2008-16_0_8.html">If the # token appears as the first token on a line, then it shall be immediately followed by a preprocessing token [MISRA2008-16_0_8-3]</A>
<LI><A HREF="MISRA2008-16_1_1.html">The defined preprocessor operator shall only be used in one of the two standard forms [MISRA2008-16_1_1-3]</A>
<LI><A HREF="MISRA2008-16_1_2.html">All #else, #elif and #endif preprocessor directives shall reside in the same file as the #if or #ifdef directive to which they are related [MISRA2008-16_1_2-3]</A>
<LI><A HREF="MISRA2008-16_2_1_a.html">Macros shall not be used [MISRA2008-16_2_1_a-3]</A>
<LI><A HREF="MISRA2008-16_2_1_b.html">The #ifndef and #endif pre-processor directives will only be used to prevent multiple inclusions of the same header file [MISRA2008-16_2_1_b-3]</A>
<LI><A HREF="MISRA2008-16_2_1_c.html">The following pre-processor directives shall not be used: #if, #elif, #else, #ifdef, #undef, #pragma [MISRA2008-16_2_1_c-3]</A>
<LI><A HREF="MISRA2008-16_2_2.html">C++ macros shall only be used for: include guards, type qualifiers, or storage class specifiers [MISRA2008-16_2_2-3]</A>
<LI><A HREF="MISRA2008-16_2_3.html">Include guards shall be provided [MISRA2008-16_2_3-3]</A>
<LI><A HREF="MISRA2008-16_2_4.html">The ', &quot;, /* or // characters shall not occur in a header file name [MISRA2008-16_2_4-3]</A>
<LI><A HREF="MISRA2008-16_2_5.html">The \ character should not occur in a header file name [MISRA2008-16_2_5-4]</A>
<LI><A HREF="MISRA2008-16_3_1.html">There shall be at most one occurrence of the # or ## operators in a single macro definition [MISRA2008-16_3_1-3]</A>
<LI><A HREF="MISRA2008-16_3_2.html">The # and ## operators should not be used [MISRA2008-16_3_2-4]</A>
<LI><A HREF="MISRA2008-16_6_1.html">All uses of the #pragma directive shall be documented [MISRA2008-16_6_1-3]</A>
<LI><A HREF="MISRA2008-17_0_1_a.html">Reserved identifiers, macros and functions in the standard library shall not be defined, redefined or undefined [MISRA2008-17_0_1_a-3]</A>
<LI><A HREF="MISRA2008-17_0_1_b.html">Reserved identifiers, macros and functions in the standard library shall not be defined, redefined or undefined [MISRA2008-17_0_1_b-3]</A>
<LI><A HREF="MISRA2008-17_0_2.html">The names of standard library macros and objects shall not be reused [MISRA2008-17_0_2-3]</A>
<LI><A HREF="MISRA2008-17_0_3.html">The names of standard library functions shall not be overridden [MISRA2008-17_0_3-3]</A>
<LI><A HREF="MISRA2008-17_0_5.html">The setjmp macro and the longjmp function shall not be used [MISRA2008-17_0_5-3]</A>
<LI><A HREF="MISRA2008-18_0_1.html">The C library shall not be used [MISRA2008-18_0_1-3]</A>
<LI><A HREF="MISRA2008-18_0_2.html">The library functions atof, atoi and atol from library &lt;cstdlib&gt; shall not be used [MISRA2008-18_0_2-3]</A>
<LI><A HREF="MISRA2008-18_0_3.html">The library functions abort, exit, getenv and system from library &lt;cstdlib&gt; shall not be used [MISRA2008-18_0_3-3]</A>
<LI><A HREF="MISRA2008-18_0_4.html">The time handling functions of library &lt;ctime&gt; shall not be used [MISRA2008-18_0_4-3]</A>
<LI><A HREF="MISRA2008-18_0_5.html">The unbounded functions of library &lt;cstring&gt; shall not be used [MISRA2008-18_0_5-3]</A>
<LI><A HREF="MISRA2008-18_2_1.html">The macro offsetof shall not be used [MISRA2008-18_2_1-3]</A>
<LI><A HREF="MISRA2008-18_4_1.html">Dynamic heap memory allocation shall not be used [MISRA2008-18_4_1-3]</A>
<LI><A HREF="MISRA2008-18_7_1.html">The signal handling facilities of &lt;csignal&gt; shall not be used [MISRA2008-18_7_1-3]</A>
<LI><A HREF="MISRA2008-19_3_1.html">The error indicator errno shall not be used [MISRA2008-19_3_1-3]</A>
<LI><A HREF="MISRA2008-27_0_1.html">The stream input/output library &lt;cstdio&gt; shall not be used [MISRA2008-27_0_1-3]</A>
<LI><A HREF="MISRA2008-2_10_1.html">Different identifiers shall be typographically unambiguous [MISRA2008-2_10_1-3]</A>
<LI><A HREF="MISRA2008-2_10_2_a.html">Identifiers declared in an inner scope shall not hide an identifier declared in an outer scope [MISRA2008-2_10_2_a-3]</A>
<LI><A HREF="MISRA2008-2_10_2_b.html">Identifiers declared in an inner scope shall not hide an identifier declared in an outer scope [MISRA2008-2_10_2_b-3]</A>
<LI><A HREF="MISRA2008-2_10_4_a.html">A class, union or enum name (including qualification, if any) shall be a unique identifier [MISRA2008-2_10_4_a-3]</A>
<LI><A HREF="MISRA2008-2_10_4_b.html">A class, union or enum name (including qualification, if any) shall be a unique identifier [MISRA2008-2_10_4_b-3]</A>
<LI><A HREF="MISRA2008-2_10_5_a.html">The identifier name of a non-member object or function with static storage duration should not be reused [MISRA2008-2_10_5_a-4]</A>
<LI><A HREF="MISRA2008-2_10_5_b.html">The identifier name of a non-member object or function with static storage duration should not be reused [MISRA2008-2_10_5_b-4]</A>
<LI><A HREF="MISRA2008-2_10_6.html">If an identifier refers to a type, it shall not also refer to an object or a function in the same scope [MISRA2008-2_10_6-3]</A>
<LI><A HREF="MISRA2008-2_13_1.html">Only those escape sequences that are defined in ISO/IEC 14882:2003 shall be used [MISRA2008-2_13_1-3]</A>
<LI><A HREF="MISRA2008-2_13_2.html">Octal constants (other than zero) and octal escape sequences (other than &quot;\0&quot;) shall not be used [MISRA2008-2_13_2-3]</A>
<LI><A HREF="MISRA2008-2_13_3.html">A &quot;U&quot; suffix shall be applied to all octal or hexadecimal integer literals of unsigned type [MISRA2008-2_13_3-3]</A>
<LI><A HREF="MISRA2008-2_13_4.html">Literal suffixes shall be upper case [MISRA2008-2_13_4-3]</A>
<LI><A HREF="MISRA2008-2_13_5.html">Narrow and wide string literals shall not be concatenated [MISRA2008-2_13_5-3]</A>
<LI><A HREF="MISRA2008-2_3_1.html">Trigraphs shall not be used [MISRA2008-2_3_1-3]</A>
<LI><A HREF="MISRA2008-2_5_1.html">Digraphs should not be used [MISRA2008-2_5_1-4]</A>
<LI><A HREF="MISRA2008-2_7_1.html">The character sequence /* shall not be used within a C-style comment [MISRA2008-2_7_1-3]</A>
<LI><A HREF="MISRA2008-2_7_2.html">Sections of code shall not be &quot;commented out&quot; using C-style comments [MISRA2008-2_7_2-3]</A>
<LI><A HREF="MISRA2008-2_7_3.html">Sections of code should not be &quot;commented out&quot; using C++ comments [MISRA2008-2_7_3-4]</A>
<LI><A HREF="MISRA2008-3_1_1.html">It shall be possible to include any header file in multiple translation units without violating the One Definition Rule [MISRA2008-3_1_1-3]</A>
<LI><A HREF="MISRA2008-3_1_2.html">Functions shall not be declared at block scope [MISRA2008-3_1_2-3]</A>
<LI><A HREF="MISRA2008-3_1_3.html">When an array is declared, its size shall either be stated explicitly or defined implicitly by initialization [MISRA2008-3_1_3-3]</A>
<LI><A HREF="MISRA2008-3_3_1.html">Objects or functions with external linkage shall be declared in a header file [MISRA2008-3_3_1-3]</A>
<LI><A HREF="MISRA2008-3_3_2.html">If a function has internal linkage then all re-declarations shall include the static storage class specifier [MISRA2008-3_3_2-3]</A>
<LI><A HREF="MISRA2008-3_4_1.html">An identifier declared to be an object or type shall be defined in a block that minimizes its visibility [MISRA2008-3_4_1-3]</A>
<LI><A HREF="MISRA2008-3_9_1.html">The types used for an object, a function return type, or a function parameter shall be token-for-token identical in all declarations and re-declarations [MISRA2008-3_9_1-3]</A>
<LI><A HREF="MISRA2008-3_9_2.html">typedefs that indicate size and signedness should be used in place of the basic numerical types [MISRA2008-3_9_2-4]</A>
<LI><A HREF="MISRA2008-3_9_3.html">The underlying bit representations of floating-point values shall not be used [MISRA2008-3_9_3-3]</A>
<LI><A HREF="MISRA2008-4_10_1.html">NULL shall not be used as an integer value [MISRA2008-4_10_1-3]</A>
<LI><A HREF="MISRA2008-4_10_2.html">Literal zero (0) shall not be used as the null-pointer-constant [MISRA2008-4_10_2-3]</A>
<LI><A HREF="MISRA2008-4_5_1.html">Expressions with type bool shall not be used as operands to built-in operators other than the assignment operator =, the logical operators &amp;&amp;, ||, !, the equality operators == and !=, the unary &amp; operator, and the conditional operator [MISRA2008-4_5_1-3]</A>
<LI><A HREF="MISRA2008-4_5_2.html">Expressions with type enum shall not be used as operands to built-in operators other than [ ], =, &nbsp;==, !=, &lt;, &lt;=, &gt;, &gt;=, and the unary &amp; operator [MISRA2008-4_5_2-3]</A>
<LI><A HREF="MISRA2008-4_5_3.html">Expressions with type (plain) char and wchar_t shall not be used as operands to built-in operators other than the assignment operator =, the equality operators == and !=, and the unary &amp; operator [MISRA2008-4_5_3-3]</A>
<LI><A HREF="MISRA2008-5_0_10.html">If the bitwise operators ~ and &lt;&lt; are applied to an operand with an underlying type of unsigned char or unsigned short, the result shall be immediately cast to the underlying type of the operand [MISRA2008-5_0_10-3]</A>
<LI><A HREF="MISRA2008-5_0_11.html">The plain char type shall only be used for the storage and use of character values [MISRA2008-5_0_11-3]</A>
<LI><A HREF="MISRA2008-5_0_12.html">signed char and unsigned char type shall only be used for the storage and use of numeric values [MISRA2008-5_0_12-3]</A>
<LI><A HREF="MISRA2008-5_0_13.html">The condition of an if-statement and the condition of an iteration-statement shall have type bool [MISRA2008-5_0_13-3]</A>
<LI><A HREF="MISRA2008-5_0_14.html">The first operand of a conditional-operator shall have type bool [MISRA2008-5_0_14-3]</A>
<LI><A HREF="MISRA2008-5_0_15.html">Array indexing shall be the only form of pointer arithmetic [MISRA2008-5_0_15-3]</A>
<LI><A HREF="MISRA2008-5_0_17.html">Subtraction between pointers shall only be applied to pointers that address elements of the same array [MISRA2008-5_0_17-3]</A>
<LI><A HREF="MISRA2008-5_0_18.html">&gt;, &gt;=, &lt;, &lt;= shall not be applied to objects of pointer type, except where they point to the same array [MISRA2008-5_0_18-3]</A>
<LI><A HREF="MISRA2008-5_0_19_a.html">The declaration of objects shall contain no more than two levels of pointer indirection [MISRA2008-5_0_19_a-3]</A>
<LI><A HREF="MISRA2008-5_0_19_b.html">The declaration of objects shall contain no more than two levels of pointer indirection [MISRA2008-5_0_19_b-3]</A>
<LI><A HREF="MISRA2008-5_0_19_c.html">The declaration of objects shall contain no more than two levels of pointer indirection [MISRA2008-5_0_19_c-3]</A>
<LI><A HREF="MISRA2008-5_0_19_d.html">The declaration of objects shall contain no more than two levels of pointer indirection [MISRA2008-5_0_19_d-3]</A>
<LI><A HREF="MISRA2008-5_0_1_a.html">The value of an expression shall be the same under any order of evaluation that the standard permits [MISRA2008-5_0_1_a-3]</A>
<LI><A HREF="MISRA2008-5_0_1_b.html">The value of an expression shall be the same under any order of evaluation that the standard permits [MISRA2008-5_0_1_b-3]</A>
<LI><A HREF="MISRA2008-5_0_1_c.html">The value of an expression shall be the same under any order of evaluation that the standard permits [MISRA2008-5_0_1_c-3]</A>
<LI><A HREF="MISRA2008-5_0_1_d.html">The value of an expression shall be the same under any order of evaluation that the standard permits [MISRA2008-5_0_1_d-3]</A>
<LI><A HREF="MISRA2008-5_0_1_e.html">The value of an expression shall be the same under any order of evaluation that the standard permits [MISRA2008-5_0_1_e-3]</A>
<LI><A HREF="MISRA2008-5_0_1_f.html">The value of an expression shall be the same under any order of evaluation that the standard permits [MISRA2008-5_0_1_f-3]</A>
<LI><A HREF="MISRA2008-5_0_1_g.html">The value of an expression shall be the same under any order of evaluation that the standard permits [MISRA2008-5_0_1_g-3]</A>
<LI><A HREF="MISRA2008-5_0_20.html">Non-constant operands to a binary bitwise operator shall have the same underlying type [MISRA2008-5_0_20-3]</A>
<LI><A HREF="MISRA2008-5_0_21.html">Bitwise operators shall only be applied to operands of unsigned underlying type [MISRA2008-5_0_21-3]</A>
<LI><A HREF="MISRA2008-5_0_2_a.html">Limited dependence should be placed on C++ operator precedence rules in expressions [MISRA2008-5_0_2_a-4]</A>
<LI><A HREF="MISRA2008-5_0_2_b.html">Limited dependence should be placed on C++ operator precedence rules in expressions [MISRA2008-5_0_2_b-4]</A>
<LI><A HREF="MISRA2008-5_0_2_c.html">Limited dependence should be placed on C++ operator precedence rules in expressions [MISRA2008-5_0_2_c-4]</A>
<LI><A HREF="MISRA2008-5_0_2_d.html">Limited dependence should be placed on C++ operator precedence rules in expressions [MISRA2008-5_0_2_d-4]</A>
<LI><A HREF="MISRA2008-5_0_2_e.html">Limited dependence should be placed on C++ operator precedence rules in expressions [MISRA2008-5_0_2_e-4]</A>
<LI><A HREF="MISRA2008-5_0_2_f.html">Limited dependence should be placed on C++ operator precedence rules in expressions [MISRA2008-5_0_2_f-4]</A>
<LI><A HREF="MISRA2008-5_0_3_a.html">A cvalue expression shall not be implicitly converted to a different underlying type [MISRA2008-5_0_3_a-3]</A>
<LI><A HREF="MISRA2008-5_0_3_b.html">A cvalue expression shall not be implicitly converted to a different underlying type [MISRA2008-5_0_3_b-3]</A>
<LI><A HREF="MISRA2008-5_0_3_c.html">A cvalue expression shall not be implicitly converted to a different underlying type [MISRA2008-5_0_3_c-3]</A>
<LI><A HREF="MISRA2008-5_0_4_a.html">An implicit integral conversion shall not change the signedness of the underlying type [MISRA2008-5_0_4_a-3]</A>
<LI><A HREF="MISRA2008-5_0_4_b.html">An implicit integral conversion shall not change the signedness of the underlying type [MISRA2008-5_0_4_b-3]</A>
<LI><A HREF="MISRA2008-5_0_5_a.html">There shall be no implicit floating-integral conversions [MISRA2008-5_0_5_a-3]</A>
<LI><A HREF="MISRA2008-5_0_5_b.html">There shall be no implicit floating-integral conversions [MISRA2008-5_0_5_b-3]</A>
<LI><A HREF="MISRA2008-5_0_5_c.html">There shall be no implicit floating-integral conversions [MISRA2008-5_0_5_c-3]</A>
<LI><A HREF="MISRA2008-5_0_6_a.html">An implicit integral or floating-point conversion shall not reduce the size of the underlying type [MISRA2008-5_0_6_a-3]</A>
<LI><A HREF="MISRA2008-5_0_6_b.html">An implicit integral or floating-point conversion shall not reduce the size of the underlying type [MISRA2008-5_0_6_b-3]</A>
<LI><A HREF="MISRA2008-5_0_6_c.html">An implicit integral or floating-point conversion shall not reduce the size of the underlying type [MISRA2008-5_0_6_c-3]</A>
<LI><A HREF="MISRA2008-5_0_7_a.html">There shall be no explicit floating-integral conversions of a cvalue expression [MISRA2008-5_0_7_a-3]</A>
<LI><A HREF="MISRA2008-5_0_7_b.html">There shall be no explicit floating-integral conversions of a cvalue expression [MISRA2008-5_0_7_b-3]</A>
<LI><A HREF="MISRA2008-5_0_8.html">An explicit integral or floating-point conversion shall not increase the size of the underlying type of a cvalue expression [MISRA2008-5_0_8-3]</A>
<LI><A HREF="MISRA2008-5_0_9.html">An explicit integral conversion shall not change the signedness of the underlying type of a cvalue expression [MISRA2008-5_0_9-3]</A>
<LI><A HREF="MISRA2008-5_14_1.html">The right hand operand of a logical &amp;&amp; or || operator shall not contain side effects [MISRA2008-5_14_1-3]</A>
<LI><A HREF="MISRA2008-5_18_1.html">The comma operator shall not be used [MISRA2008-5_18_1-3]</A>
<LI><A HREF="MISRA2008-5_2_1.html">Each operand of a logical &amp;&amp; or || shall be a postfix-expression [MISRA2008-5_2_1-3]</A>
<LI><A HREF="MISRA2008-5_2_10.html">The increment (++) and decrement (--) operators should not be mixed with other operators in an expression [MISRA2008-5_2_10-4]</A>
<LI><A HREF="MISRA2008-5_2_11.html">The comma operator, &amp;&amp; operator and the || operator shall not be overloaded [MISRA2008-5_2_11-3]</A>
<LI><A HREF="MISRA2008-5_2_12.html">An identifier with array type passed as a function argument shall not decay to a pointer [MISRA2008-5_2_12-3]</A>
<LI><A HREF="MISRA2008-5_2_2.html">A pointer to a virtual base class shall only be cast to a pointer to a derived class by means of dynamic_cast [MISRA2008-5_2_2-3]</A>
<LI><A HREF="MISRA2008-5_2_3.html">Casts from a base class to a derived class should not be performed on polymorphic types [MISRA2008-5_2_3-4]</A>
<LI><A HREF="MISRA2008-5_2_4.html">C-style casts (other than void casts) and functional notation casts (other than explicit constructor calls) shall not be used [MISRA2008-5_2_4-3]</A>
<LI><A HREF="MISRA2008-5_2_5.html">A cast shall not remove any const or volatile qualification from the type of a pointer or reference [MISRA2008-5_2_5-3]</A>
<LI><A HREF="MISRA2008-5_2_6.html">A cast shall not convert a pointer to a function to any other pointer type, including a pointer to function type [MISRA2008-5_2_6-3]</A>
<LI><A HREF="MISRA2008-5_2_7.html">An object with pointer type shall not be converted to an unrelated pointer type, either directly or indirectly [MISRA2008-5_2_7-3]</A>
<LI><A HREF="MISRA2008-5_2_8.html">An object with integer type or pointer to void type shall not be converted to an object with pointer type [MISRA2008-5_2_8-3]</A>
<LI><A HREF="MISRA2008-5_2_9.html">A cast should not convert a pointer type to an integral type [MISRA2008-5_2_9-4]</A>
<LI><A HREF="MISRA2008-5_3_1.html">Each operand of the ! operator, the logical &amp;&amp; or the logical || operators shall have type bool [MISRA2008-5_3_1-3]</A>
<LI><A HREF="MISRA2008-5_3_2.html">The unary minus operator shall not be applied to an expression whose underlying type is unsigned [MISRA2008-5_3_2-3]</A>
<LI><A HREF="MISRA2008-5_3_3.html">The unary &amp; operator shall not be overloaded [MISRA2008-5_3_3-3]</A>
<LI><A HREF="MISRA2008-5_3_4.html">Evaluation of the operand to the sizeof operator shall not contain side effects [MISRA2008-5_3_4-3]</A>
<LI><A HREF="MISRA2008-5_8_1.html">The right hand operand of a shift operator shall lie between zero and one less than the width in bits of the underlying type of the left hand operand [MISRA2008-5_8_1-3]</A>
<LI><A HREF="MISRA2008-6_2_1.html">Assignment operators shall not be used in sub-expressions [MISRA2008-6_2_1-3]</A>
<LI><A HREF="MISRA2008-6_2_2.html">Floating-point expressions shall not be directly or indirectly tested for equality or inequality [MISRA2008-6_2_2-3]</A>
<LI><A HREF="MISRA2008-6_2_3.html">Before preprocessing, a null statement shall only occur on a line by itself; it may be followed by a comment, provided that the first character following the null statement is a white-space character [MISRA2008-6_2_3-3]</A>
<LI><A HREF="MISRA2008-6_3_1.html">The statement forming the body of a switch, while, do &nbsp;while or for statement shall be a compound statement [MISRA2008-6_3_1-3]</A>
<LI><A HREF="MISRA2008-6_4_1.html">An if ( condition ) construct shall be followed by a compound statement. The else keyword shall be followed by either a compound statement, or another if statement [MISRA2008-6_4_1-3]</A>
<LI><A HREF="MISRA2008-6_4_2.html">All if ... else if constructs shall be terminated with an else clause [MISRA2008-6_4_2-3]</A>
<LI><A HREF="MISRA2008-6_4_3_a.html">A switch statement shall be a well-formed switch statement [MISRA2008-6_4_3_a-3]</A>
<LI><A HREF="MISRA2008-6_4_3_b.html">A switch statement shall be a well-formed switch statement [MISRA2008-6_4_3_b-3]</A>
<LI><A HREF="MISRA2008-6_4_3_c.html">A switch statement shall be a well-formed switch statement [MISRA2008-6_4_3_c-3]</A>
<LI><A HREF="MISRA2008-6_4_3_d.html">A switch statement shall be a well-formed switch statement [MISRA2008-6_4_3_d-3]</A>
<LI><A HREF="MISRA2008-6_4_3_e.html">A switch statement shall be a well-formed switch statement [MISRA2008-6_4_3_e-3]</A>
<LI><A HREF="MISRA2008-6_4_4.html">A switch-label shall only be used when the most closely-enclosing compound statement is the body of a switch statement [MISRA2008-6_4_4-3]</A>
<LI><A HREF="MISRA2008-6_4_5.html">An unconditional throw or break statement shall terminate every non-empty switch-clause [MISRA2008-6_4_5-3]</A>
<LI><A HREF="MISRA2008-6_4_6.html">The final clause of a switch statement shall be the default-clause [MISRA2008-6_4_6-3]</A>
<LI><A HREF="MISRA2008-6_4_7.html">The condition of a switch statement shall not have bool type [MISRA2008-6_4_7-3]</A>
<LI><A HREF="MISRA2008-6_4_8.html">Every switch statement shall have at least one case-clause [MISRA2008-6_4_8-3]</A>
<LI><A HREF="MISRA2008-6_5_1.html">A for loop shall contain a single loop-counter which shall not have floating type [MISRA2008-6_5_1-3]</A>
<LI><A HREF="MISRA2008-6_5_2.html">If loop-counter is not modified by -- or ++, then, within condition, the loop-counter shall only be used as an operand to &lt;=, &lt;, &gt; or &gt;= [MISRA2008-6_5_2-3]</A>
<LI><A HREF="MISRA2008-6_5_3.html">The loop-counter shall not be modified within condition or statement [MISRA2008-6_5_3-3]</A>
<LI><A HREF="MISRA2008-6_5_4.html">The loop-counter shall be modified by one of: --, ++, -=n, or +=n; where n remains constant for the duration of the loop [MISRA2008-6_5_4-3]</A>
<LI><A HREF="MISRA2008-6_5_5.html">A loop-control-variable other than the loop-counter shall not be modified within condition or expression [MISRA2008-6_5_5-3]</A>
<LI><A HREF="MISRA2008-6_5_6.html">A loop-control-variable other than the loop-counter which is modified in statement within a body of the loop shall have type bool [MISRA2008-6_5_6-3]</A>
<LI><A HREF="MISRA2008-6_6_1.html">Any label referenced by a goto statement shall be declared in the same block, or in a block enclosing the goto statement [MISRA2008-6_6_1-3]</A>
<LI><A HREF="MISRA2008-6_6_2.html">The goto statement shall jump to a label declared later in the same function body [MISRA2008-6_6_2-3]</A>
<LI><A HREF="MISRA2008-6_6_3.html">The continue statement shall only be used within a well-formed for loop [MISRA2008-6_6_3-3]</A>
<LI><A HREF="MISRA2008-6_6_4.html">For any iteration statement there shall be no more than one break or goto statement used for loop termination [MISRA2008-6_6_4-3]</A>
<LI><A HREF="MISRA2008-6_6_5.html">A function shall have a single point of exit at the end of the function [MISRA2008-6_6_5-3]</A>
<LI><A HREF="MISRA2008-7_1_1.html">A variable which is not modified shall be const qualified [MISRA2008-7_1_1-3]</A>
<LI><A HREF="MISRA2008-7_1_2_a.html">A pointer parameter in a function shall be declared as pointer to const if the corresponding object is not modified [MISRA2008-7_1_2_a-3]</A>
<LI><A HREF="MISRA2008-7_1_2_b.html">A reference parameter in a function shall be declared as reference to const if the corresponding object is not modified [MISRA2008-7_1_2_b-3]</A>
<LI><A HREF="MISRA2008-7_3_1.html">The global namespace shall only contain main, namespace declarations and extern &quot;C&quot; declarations [MISRA2008-7_3_1-3]</A>
<LI><A HREF="MISRA2008-7_3_2.html">The identifier main shall not be used for a function other than the global function main [MISRA2008-7_3_2-3]</A>
<LI><A HREF="MISRA2008-7_3_3.html">There shall be no unnamed namespaces in header files [MISRA2008-7_3_3-3]</A>
<LI><A HREF="MISRA2008-7_3_4.html">using-directives shall not be used [MISRA2008-7_3_4-3]</A>
<LI><A HREF="MISRA2008-7_3_5.html">Multiple declarations for an identifier in the same namespace shall not straddle a using-declaration for that identifier [MISRA2008-7_3_5-3]</A>
<LI><A HREF="MISRA2008-7_4_1.html">All usage of assembler shall be documented [MISRA2008-7_4_1-3]</A>
<LI><A HREF="MISRA2008-7_4_2.html">Assembler instructions shall only be introduced using the asm declaration [MISRA2008-7_4_2-3]</A>
<LI><A HREF="MISRA2008-7_4_3.html">Assembly language shall be encapsulated and isolated [MISRA2008-7_4_3-3]</A>
<LI><A HREF="MISRA2008-7_5_1.html">A function shall not return a reference or a pointer to an automatic variable (including parameters), defined within the function [MISRA2008-7_5_1-3]</A>
<LI><A HREF="MISRA2008-7_5_2.html">The address of an object with automatic storage shall not be assigned to another object that may persist after the first object has ceased to exist [MISRA2008-7_5_2-3]</A>
<LI><A HREF="MISRA2008-7_5_3.html">A function shall not return a reference or a pointer to a parameter that is passed by reference or const reference [MISRA2008-7_5_3-3]</A>
<LI><A HREF="MISRA2008-7_5_4.html">Functions should not call themselves, either directly or indirectly [MISRA2008-7_5_4-4]</A>
<LI><A HREF="MISRA2008-8_0_1.html">An init-declarator-list or a member-declarator-list shall consist of a single init-declarator or member-declarator respectively [MISRA2008-8_0_1-3]</A>
<LI><A HREF="MISRA2008-8_3_1.html">Parameters in an overriding virtual function shall either use the same default arguments as the function they override, or else shall not specify any default arguments [MISRA2008-8_3_1-3]</A>
<LI><A HREF="MISRA2008-8_4_1.html">Functions shall not be defined using the ellipsis notation [MISRA2008-8_4_1-3]</A>
<LI><A HREF="MISRA2008-8_4_2.html">The identifiers used for the parameters in a re-declaration of a function shall be identical to those in the declaration [MISRA2008-8_4_2-3]</A>
<LI><A HREF="MISRA2008-8_4_3.html">All exit paths from a function with non-void return type shall have an explicit return statement with an expression [MISRA2008-8_4_3-3]</A>
<LI><A HREF="MISRA2008-8_5_1.html">All variables shall have a defined value before they are used [MISRA2008-8_5_1-3]</A>
<LI><A HREF="MISRA2008-8_5_2.html">Braces shall be used to indicate and match the structure in the non-zero initialization of arrays and structures [MISRA2008-8_5_2-3]</A>
<LI><A HREF="MISRA2008-8_5_3.html">In an enumerator list, the = construct shall not be used to explicitly initialize members other than the first, unless all items are explicitly initialized [MISRA2008-8_5_3-3]</A>
<LI><A HREF="MISRA2008-9_3_1.html">const member functions shall not return non-const pointers or references to class-data [MISRA2008-9_3_1-3]</A>
<LI><A HREF="MISRA2008-9_3_2_a.html">Protected member functions shall not return non-const handles to class-data [MISRA2008-9_3_2_a-3]</A>
<LI><A HREF="MISRA2008-9_3_2_b.html">Public member functions shall not return non-const handles to class-data [MISRA2008-9_3_2_b-3]</A>
<LI><A HREF="MISRA2008-9_3_3.html">If a member function can be made static then it shall be made static, otherwise if it can be made const then it shall be made const [MISRA2008-9_3_3-3]</A>
<LI><A HREF="MISRA2008-9_5_1.html">Unions shall not be used [MISRA2008-9_5_1-3]</A>
<LI><A HREF="MISRA2008-9_6_2.html">Bit-fields shall be either bool type or an explicitly unsigned or signed integral type [MISRA2008-9_6_2-3]</A>
<LI><A HREF="MISRA2008-9_6_3.html">Bit-fields shall not have enum type [MISRA2008-9_6_3-3]</A>
<LI><A HREF="MISRA2008-9_6_4.html">Named bit-fields with signed integer type shall have a length of more than one bit [MISRA2008-9_6_4-3]</A>
</UL>
<LI><B><A HREF="MRM.html">Memory and Resource Management [MRM]</A></B>
<UL>
<LI><A HREF="MRM-01.html">Do not allocate resources in function argument list because the order of evaluation of a function's parameters is undefined [MRM-01-1]</A>
<LI><A HREF="MRM-02.html">Do not allocate more than one resource in a single statement [MRM-02-3]</A>
<LI><A HREF="MRM-04.html">All classes should contain the assignment operator or appropriate comment [MRM-04-3]</A>
<LI><A HREF="MRM-05.html">All classes should contain the copy constructor or appropriate comment [MRM-05-3]</A>
<LI><A HREF="MRM-06.html">Use the same form in corresponding calls to new/malloc and delete/free [MRM-06-1]</A>
<LI><A HREF="MRM-07.html">Don't memcpy or memcmp non-PODs [MRM-07-3]</A>
<LI><A HREF="MRM-08.html">Do not invoke malloc/realloc for objects having constructors [MRM-08-1]</A>
<LI><A HREF="MRM-09.html">Always assign a new value to a pointer that points to deallocated memory [MRM-09-3]</A>
<LI><A HREF="MRM-10.html">Always assign a new value to a pointer that points to deallocated memory [MRM-10-3]</A>
<LI><A HREF="MRM-11.html">Always assign a new value to a pointer that points to deallocated memory [MRM-11-3]</A>
<LI><A HREF="MRM-12.html">Adhere to convention when writing new and delete [MRM-12-3]</A>
<LI><A HREF="MRM-13.html">Adhere to convention when writing new [MRM-13-3]</A>
<LI><A HREF="MRM-14.html">If a class defines any overload of operator new, it should provide overloads of all three of plain, in-place, and non-throwing operator new [MRM-14-3]</A>
<LI><A HREF="MRM-15.html">If a class defines any overload of operator new[], it should provide overloads of all three of plain, in-place, and non-throwing operator new[] [MRM-15-3]</A>
<LI><A HREF="MRM-16.html">If a class defines any overload of operator delete, it should provide overloads of all three of plain, in-place, and non-throwing operator delete [MRM-16-3]</A>
<LI><A HREF="MRM-17.html">If a class defines any overload of operator delete[], it should provide overloads of all three of plain, in-place, and non-throwing operator delete[] [MRM-17-3]</A>
<LI><A HREF="MRM-18.html">Do not allocate memory and expect that someone else will deallocate it later [MRM-18-3]</A>
<LI><A HREF="MRM-19.html">Do not allocate memory and expect that someone else will deallocate it later [MRM-19-3]</A>
<LI><A HREF="MRM-20.html">Do not allocate memory and expect that someone else will deallocate it later [MRM-20-3]</A>
<LI><A HREF="MRM-21.html">Use objects to manage resources [MRM-21-3]</A>
<LI><A HREF="MRM-22.html">Use objects to manage resources [MRM-22-3]</A>
<LI><A HREF="MRM-23.html">Never return a dereferenced local pointer initialized by new in this function scope [MRM-23-2]</A>
<LI><A HREF="MRM-24.html">Never return a reference to a local object [MRM-24-1]</A>
<LI><A HREF="MRM-25.html">Store newed objects in smart pointers in standalone statements [MRM-25-3]</A>
<LI><A HREF="MRM-26.html">Write operator delete if you write operator new [MRM-26-3]</A>
<LI><A HREF="MRM-27.html">Write operator delete[] if you write operator new[] [MRM-27-3]</A>
<LI><A HREF="MRM-28.html">Always provide new and delete together [MRM-28-3]</A>
<LI><A HREF="MRM-29.html">Always provide new[] and delete[] together [MRM-29-3]</A>
<LI><A HREF="MRM-30.html">Use allocation by declaration rather than by new or malloc [MRM-30-3]</A>
<LI><A HREF="MRM-31.html">Freed memory shouldn't be accessed under any circumstances. Destructor should not be called manually [MRM-31-3]</A>
<LI><A HREF="MRM-32.html">Avoid hiding the global new [MRM-32-1]</A>
<LI><A HREF="MRM-33.html">Call delete on pointer members in destructors [MRM-33-2]</A>
<LI><A HREF="MRM-34.html">Check the return value of new [MRM-34-3]</A>
<LI><A HREF="MRM-35.html">Never provide brackets ([]) for delete when deallocating non-arrays [MRM-35-3]</A>
<LI><A HREF="MRM-36.html">Always provide empty brackets ([]) for delete when deallocating arrays [MRM-36-3]</A>
<LI><A HREF="MRM-37.html">Declare an assignment operator for classes with dynamically allocated memory [MRM-37-1]</A>
<LI><A HREF="MRM-38.html">Declare a copy constructor for classes with dynamically allocated memory [MRM-38-1]</A>
<LI><A HREF="MRM-39.html">Provide error handling for file opening errors right next to the call to fopen [MRM-39-2]</A>
<LI><A HREF="MRM-40.html">Copy and destroy consistently [MRM-40-3]</A>
<LI><A HREF="MRM-41.html">A copy constructor shall copy all data members and bases [MRM-41-2]</A>
<LI><A HREF="MRM-42.html">Call fclose() on pointer member in destructor if the pointer was used to open a file [MRM-42-2]</A>
<LI><A HREF="MRM-43.html">The assignment operator must assign all members, including those in base classes [MRM-43-2]</A>
<LI><A HREF="MRM-44.html">Avoid passing address of auto variable into caller space [MRM-44-2]</A>
<LI><A HREF="MRM-45.html">Do not use sizeof operator on pointer type to specify the size of the memory to be allocated via 'malloc', 'calloc' or 'realloc' function [MRM-45-3]</A>
<LI><A HREF="MRM-46.html">Do not use calloc, malloc, realloc and free functions [MRM-46-3]</A>
<LI><A HREF="MRM-47.html">Classes containing at least one non-static member variable should declare the assignment operator or contain appropriate comment [MRM-47-3]</A>
<LI><A HREF="MRM-48.html">Classes containing at least one non-static member variable should declare the copy constructor or contain appropriate comment [MRM-48-3]</A>
</UL>
<LI><B><A HREF="NAMING.html">Naming Conventions [NAMING]</A></B>
<UL>
<LI><B><A HREF="NAMING-HN.html">Hungarian Notation [NAMING-HN]</A></B>
<UL>
<LI><A HREF="NAMING-HN-01.html">Hungarian notation for array variables and parameters [NAMING-HN-01-3]</A>
<LI><A HREF="NAMING-HN-02.html">Hungarian notation for bool types [NAMING-HN-02-3]</A>
<LI><A HREF="NAMING-HN-03.html">Hungarian notation for bool pointer, array, or reference types [NAMING-HN-03-3]</A>
<LI><A HREF="NAMING-HN-04.html">Hungarian notation for byte types [NAMING-HN-04-3]</A>
<LI><A HREF="NAMING-HN-05.html">Hungarian notation for byte pointer, array, or reference types [NAMING-HN-05-3]</A>
<LI><A HREF="NAMING-HN-06.html">Hungarian notation for char types [NAMING-HN-06-3]</A>
<LI><A HREF="NAMING-HN-07.html">Hungarian notation for array of char types [NAMING-HN-07-3]</A>
<LI><A HREF="NAMING-HN-08.html">Hungarian notation for pointer, array, or reference to array of char types [NAMING-HN-08-3]</A>
<LI><A HREF="NAMING-HN-09.html">Hungarian notation for char pointer, array, or reference types [NAMING-HN-09-3]</A>
<LI><A HREF="NAMING-HN-10.html">Hungarian notation for char pointer or reference types [NAMING-HN-10-3]</A>
<LI><A HREF="NAMING-HN-11.html">Hungarian notation for constant parameters [NAMING-HN-11-3]</A>
<LI><A HREF="NAMING-HN-12.html">Hungarian notation for double-precision floating point types [NAMING-HN-12-3]</A>
<LI><A HREF="NAMING-HN-13.html">Hungarian notation for double-precision floating point pointer, array, or reference types [NAMING-HN-13-3]</A>
<LI><A HREF="NAMING-HN-14.html">Hungarian notation for dword types [NAMING-HN-14-3]</A>
<LI><A HREF="NAMING-HN-15.html">Hungarian notation for dword pointer, array, or reference types [NAMING-HN-15-3]</A>
<LI><A HREF="NAMING-HN-16.html">Hungarian notation for dynamically allocated array [NAMING-HN-16-3]</A>
<LI><A HREF="NAMING-HN-17.html">Hungarian notation for floating point types [NAMING-HN-17-3]</A>
<LI><A HREF="NAMING-HN-18.html">Hungarian notation for floating point pointer, array, or reference types [NAMING-HN-18-3]</A>
<LI><A HREF="NAMING-HN-19.html">Hungarian notation for class declaration [NAMING-HN-19-3]</A>
<LI><A HREF="NAMING-HN-20.html">Hungarian notation for structs declaration [NAMING-HN-20-3]</A>
<LI><A HREF="NAMING-HN-21.html">Hungarian notation for ifstream type variables and parameters [NAMING-HN-21-3]</A>
<LI><A HREF="NAMING-HN-22.html">Hungarian notation for int types [NAMING-HN-22-3]</A>
<LI><A HREF="NAMING-HN-23.html">Hungarian notation for int pointer, array, or reference types [NAMING-HN-23-3]</A>
<LI><A HREF="NAMING-HN-24.html">Hungarian notation for istream type parameters and variables [NAMING-HN-24-3]</A>
<LI><A HREF="NAMING-HN-25.html">Hungarian notation for long int types [NAMING-HN-25-3]</A>
<LI><A HREF="NAMING-HN-26.html">Hungarian notation for long double-precision floating point types [NAMING-HN-26-3]</A>
<LI><A HREF="NAMING-HN-27.html">Hungarian notation for long double-precision floating point pointer, array, or reference types [NAMING-HN-27-3]</A>
<LI><A HREF="NAMING-HN-28.html">Hungarian notation for long int pointer, array, or reference types [NAMING-HN-28-3]</A>
<LI><A HREF="NAMING-HN-29.html">Hungarian notation for member variables [NAMING-HN-29-3]</A>
<LI><A HREF="NAMING-HN-30.html">Hungarian notation for int types [NAMING-HN-30-3]</A>
<LI><A HREF="NAMING-HN-31.html">Hungarian notation for int pointer, array, or reference types [NAMING-HN-31-3]</A>
<LI><A HREF="NAMING-HN-32.html">Hungarian notation for ofstream type parameters and variables [NAMING-HN-32-3]</A>
<LI><A HREF="NAMING-HN-33.html">Hungarian notation for ostream type parameters and variables [NAMING-HN-33-3]</A>
<LI><A HREF="NAMING-HN-34.html">Hungarian notation for pointer [NAMING-HN-34-3]</A>
<LI><A HREF="NAMING-HN-35.html">Hungarian notation for reference parameters [NAMING-HN-35-3]</A>
<LI><A HREF="NAMING-HN-36.html">Hungarian notation for short int types [NAMING-HN-36-3]</A>
<LI><A HREF="NAMING-HN-37.html">Hungarian notation for short int pointer, array, or reference types [NAMING-HN-37-3]</A>
<LI><A HREF="NAMING-HN-38.html">Hungarian notation for static variables [NAMING-HN-38-3]</A>
<LI><A HREF="NAMING-HN-39.html">Hungarian notation for string types [NAMING-HN-39-3]</A>
<LI><A HREF="NAMING-HN-40.html">Hungarian notation for string pointer, array, or reference types [NAMING-HN-40-3]</A>
<LI><A HREF="NAMING-HN-41.html">Hungarian notation for unsigned types [NAMING-HN-41-3]</A>
<LI><A HREF="NAMING-HN-42.html">Hungarian notation for void pointer types [NAMING-HN-42-3]</A>
<LI><A HREF="NAMING-HN-43.html">Hungarian notation for word types [NAMING-HN-43-3]</A>
<LI><A HREF="NAMING-HN-44.html">Hungarian notation for word pointer, array, or reference types [NAMING-HN-44-3]</A>
</UL>
<LI><A HREF="NAMING-01.html">All &quot;#define&quot; constants shall be in uppercase [NAMING-01-3]</A>
<LI><A HREF="NAMING-02.html">In an enumerated list, list members (elements) shall be in uppercase and names or tags for the list shall be in lowercase [NAMING-02-3]</A>
<LI><A HREF="NAMING-03.html">Use lowercase for file names [NAMING-03-3]</A>
<LI><A HREF="NAMING-04.html">Global prefixes should only be used for global variables [NAMING-04-3]</A>
<LI><A HREF="NAMING-05.html">Begin local variable names with a lowercase letters [NAMING-05-3]</A>
<LI><A HREF="NAMING-06.html">Begin global variable names with a lowercase letters [NAMING-06-3]</A>
<LI><A HREF="NAMING-07.html">Begin member variable names with a lowercase letters [NAMING-07-3]</A>
<LI><A HREF="NAMING-08.html">Begin all boolean type variables with 'b' [NAMING-08-3]</A>
<LI><A HREF="NAMING-09.html">Begin class, struct, union, enum, and typedef names with an uppercase letter [NAMING-09-3]</A>
<LI><A HREF="NAMING-10.html">Class, struct, union, enum, and typedef names are to start with an uppercase letter [NAMING-10-3]</A>
<LI><A HREF="NAMING-11.html">Enumerated type name shall begin with an uppercase letter prefixed by software element and suffixed by '_t' [NAMING-11-3]</A>
<LI><A HREF="NAMING-12.html">Struct type name shall begin with an uppercase letter prefixed by software element and suffixed by '_t' [NAMING-12-3]</A>
<LI><A HREF="NAMING-13.html">Begin constant variables with 'c' [NAMING-13-3]</A>
<LI><A HREF="NAMING-14.html">Begin class data member names with 'its' [NAMING-14-3]</A>
<LI><A HREF="NAMING-15.html">Begin all double type variable with 'd' [NAMING-15-3]</A>
<LI><A HREF="NAMING-16.html">Begin all float type variables with 'f' [NAMING-16-3]</A>
<LI><A HREF="NAMING-17.html">Begin all function names with uppercase letter [NAMING-17-3]</A>
<LI><A HREF="NAMING-18.html">Begin global variable names with 'the' [NAMING-18-3]</A>
<LI><A HREF="NAMING-19.html">Begin all integer type variable with 'i' [NAMING-19-3]</A>
<LI><A HREF="NAMING-20.html">Functions that begin with 'is' should return boolean values [NAMING-20-3]</A>
<LI><A HREF="NAMING-21.html">Begin all long integer variables with 'li' [NAMING-21-3]</A>
<LI><A HREF="NAMING-22.html">Prefix a variable type 'pointer' with a 'p' character [NAMING-22-3]</A>
<LI><A HREF="NAMING-23.html">Begin all short integer variables with 'si' [NAMING-23-3]</A>
<LI><A HREF="NAMING-24.html">Begin all signed character variables with 'c' [NAMING-24-3]</A>
<LI><A HREF="NAMING-25.html">Begin all terminated characters string variables with 'sz' [NAMING-25-3]</A>
<LI><A HREF="NAMING-26.html">Begin all unsigned character type variables with 'uc' [NAMING-26-3]</A>
<LI><A HREF="NAMING-27.html">Begin all unsigned integer type variables with 'ui' [NAMING-27-3]</A>
<LI><A HREF="NAMING-28.html">Use lowercase letters for structure and union member names [NAMING-28-3]</A>
<LI><A HREF="NAMING-29.html">Append names of non-scalar typedefs with &quot;_t&quot; [NAMING-29-3]</A>
<LI><A HREF="NAMING-30.html">Use the &quot;.c&quot; extension for names of source files [NAMING-30-3]</A>
<LI><A HREF="NAMING-31.html">Do not use typenames that differ only by the use of uppercase and lowercase letters [NAMING-31-3]</A>
<LI><A HREF="NAMING-32.html">An include file for a class should have a file name of the form &lt;class name&gt; + extension [NAMING-32-3]</A>
<LI><A HREF="NAMING-33.html">Do not use identifiers which begin with one or two underscores (`_' or `__') [NAMING-33-3]</A>
<LI><A HREF="NAMING-34.html">Global function names should start with lowercase [NAMING-34-3]</A>
<LI><A HREF="NAMING-35.html">Member function names should start with lowercase [NAMING-35-3]</A>
<LI><A HREF="NAMING-36.html">Names of parameters in declaration and definition should be identical [NAMING-36-3]</A>
<LI><A HREF="NAMING-37.html">Include files in C++ always have the file name extension &quot;.hh&quot; [NAMING-37-3]</A>
<LI><A HREF="NAMING-38.html">Implementation files in C++ always have the file name extension &quot;.cc&quot; [NAMING-38-3]</A>
<LI><A HREF="NAMING-39.html">Inline definition files always have the file name extension &quot;.icc&quot; [NAMING-39-3]</A>
<LI><A HREF="NAMING-40.html">Only the first word of the name of a class, structure, namespace, enumeration, or typedef will begin with an uppercase letter [NAMING-40-3]</A>
<LI><A HREF="NAMING-41.html">Header files will always have a file name extension of &quot;.h&quot; [NAMING-41-3]</A>
<LI><A HREF="NAMING-42.html">Identifiers for constant and enumerator values shall be lowercase [NAMING-42-2]</A>
<LI><A HREF="NAMING-43.html">Implementation files will always have a file name extension of &quot;.cpp&quot; [NAMING-43-3]</A>
<LI><A HREF="NAMING-44.html">All letters contained in function and variable names will be composed entirely of lowercase letters [NAMING-44-3]</A>
<LI><A HREF="NAMING-45.html">Identifiers will not differ by mixture of case, the underscore character, interchange of the similarly looking letters and numbers [NAMING-45-3]</A>
<LI><A HREF="NAMING-46.html">The ', &quot;, /* or // characters shall not occur in a header file name [NAMING-46-3]</A>
<LI><A HREF="NAMING-47.html">Different identifiers shall be typographically unambiguous [NAMING-47-3]</A>
<LI><A HREF="NAMING-48.html">The \ character should not occur in a header file name [NAMING-48-3]</A>
</UL>
<LI><B><A HREF="OOP.html">Object Oriented [OOP]</A></B>
<UL>
<LI><A HREF="OOP-01.html">Base class copy constructor should be protected or public with smart pointer as parameter [OOP-01-3]</A>
<LI><A HREF="OOP-02.html">Avoid slicing. Consider Clone instead of copying in base classes [OOP-02-3]</A>
<LI><A HREF="OOP-03.html">Class cannot inherit other class more than once unless it is virtual inheritance [OOP-03-1]</A>
<LI><A HREF="OOP-04.html">Do not derive functions with the same name from more than one base class [OOP-04-3]</A>
<LI><A HREF="OOP-05.html">Do not use multiple inheritance [OOP-05-2]</A>
<LI><A HREF="OOP-06.html">For multiple inheritance use virtual common base class [OOP-06-3]</A>
<LI><A HREF="OOP-07.html">Be wary about using multiple inheritance of classes that are not abstract interfaces [OOP-07-1]</A>
<LI><A HREF="OOP-08.html">Do not directly access global data from a constructor [OOP-08-1]</A>
<LI><A HREF="OOP-09.html">Avoid the use of global objects in destructors [OOP-09-3]</A>
<LI><A HREF="OOP-10.html">Avoid using global data in member functions [OOP-10-2]</A>
<LI><A HREF="OOP-11.html">Avoid using the friend mechanism [OOP-11-3]</A>
<LI><A HREF="OOP-12.html">Protected member function shall not return non-const handles to private class-data [OOP-12-3]</A>
<LI><A HREF="OOP-13.html">Do not redefine an inherited virtual function with a different default parameter value [OOP-13-3]</A>
<LI><A HREF="OOP-14.html">Consider use composition instead of private inheritance [OOP-14-3]</A>
<LI><A HREF="OOP-15.html">Don't change default arguments of virtual functions [OOP-15-1]</A>
<LI><A HREF="OOP-16.html">Avoid calling virtual functions from constructors and destructors [OOP-16-1]</A>
<LI><A HREF="OOP-17.html">Write a using declaration to redeclare overloaded functions [OOP-17-4]</A>
<LI><A HREF="OOP-18.html">Avoid &quot;public&quot; data members [OOP-18-2]</A>
<LI><A HREF="OOP-19.html">Avoid 'protected' data members [OOP-19-2]</A>
<LI><A HREF="OOP-20.html">Avoid unnecessary explicit cast from derived to a base class [OOP-20-3]</A>
<LI><A HREF="OOP-21.html">Use the virtual keyword if a subclass implements a virtual function [OOP-21-3]</A>
<LI><A HREF="OOP-22.html">Define a virtual destructor in classes used as base classes which have virtual functions [OOP-22-1]</A>
<LI><A HREF="OOP-23.html">If a class has virtual functions it shall have a virtual destructor [OOP-23-2]</A>
<LI><A HREF="OOP-24.html">Make destructors virtual in base classes [OOP-24-1]</A>
<LI><A HREF="OOP-25.html">Avoid declaring virtual functions inline [OOP-25-3]</A>
<LI><A HREF="OOP-26.html">Never convert pointers to objects of a derived class to pointers to objects of a virtual base class [OOP-26-3]</A>
<LI><A HREF="OOP-27.html">Declare copy assignment operator for class with reference or const members [OOP-27-3]</A>
<LI><A HREF="OOP-28.html">A pointer to a class may not be converted to a pointer of a second class unless the first class inherits from the second [OOP-28-4]</A>
<LI><A HREF="OOP-29.html">A pointer to an abstract class shall not be converted to a pointer of a class that inherits from that abstract class [OOP-29-1]</A>
<LI><A HREF="OOP-30.html">Declare the copy constructor and copy assignment operator private not in class itself, but in a specifically designed base class [OOP-30-3]</A>
<LI><A HREF="OOP-31.html">Make base class destructors public and virtual, or protected and nonvirtual [OOP-31-1]</A>
<LI><A HREF="OOP-32.html">Never redefine an inherited nonvirtual function [OOP-32-3]</A>
<LI><A HREF="OOP-33.html">Do not redefine an inherited nonvirtual function with template parameter [OOP-33-3]</A>
<LI><A HREF="OOP-34.html">Check for assignment to self in operator= [OOP-34-4]</A>
<LI><A HREF="OOP-35.html">Avoid casts down the inheritance hierarchy [OOP-35-5]</A>
<LI><A HREF="OOP-36.html">Public member functions shall not return non-const handles to private/protected class-data [OOP-36-3]</A>
<LI><A HREF="OOP-37.html">Prefer composition when don't need inheritance [OOP-37-5]</A>
<LI><A HREF="OOP-38.html">If a class destructor is called and the class has virtual functions it shall have a virtual destructor [OOP-38-1]</A>
<LI><A HREF="OOP-39.html">A stateful virtual base shall be explicitly declared in each derived class that accesses it [OOP-39-2]</A>
<LI><A HREF="OOP-40.html">Hierarchies should be based on abstract classes [OOP-40-4]</A>
<LI><A HREF="OOP-41.html">A base class shall not be both virtual and non-virtual in the same hierarchy [OOP-41-2]</A>
<LI><A HREF="OOP-42.html">The copy assignment operator shall be declared protected or private in an abstract class [OOP-42-3]</A>
<LI><A HREF="OOP-43.html">A virtual function shall only be overridden by a pure virtual function if it is itself declared as pure virtual [OOP-43-4]</A>
<LI><A HREF="OOP-44.html">There shall be no more than one definition of each virtual function on each path through the inheritance hierarchy [OOP-44-3]</A>
<LI><A HREF="OOP-45.html">All constructors that are callable with a single argument of fundamental type shall be declared explicit [OOP-45-3]</A>
<LI><A HREF="OOP-46.html">A copy constructor shall only initialize its base classes and the non-static members of the class of which it is a member [OOP-46-3]</A>
<LI><A HREF="OOP-47.html">Classes should not be derived from virtual bases [OOP-47-3]</A>
<LI><A HREF="OOP-48.html">Member data in non-POD class types shall be private [OOP-48-3]</A>
<LI><A HREF="OOP-49.html">Casts from a base class to a derived class should not be performed on polymorphic types [OOP-49-1]</A>
<LI><A HREF="OOP-50.html">A pointer to a virtual base class shall only be cast to a pointer to a derived class by means of dynamic_cast [OOP-50-3]</A>
<LI><A HREF="OOP-51.html">Use namespace instead of class or structure containing only static functions [OOP-51-5]</A>
</UL>
<LI><B><A HREF="OPT.html">Optimization [OPT]</A></B>
<UL>
<LI><A HREF="OPT-01.html">Declare variables as locally as possible [OPT-01-3]</A>
<LI><A HREF="OPT-02.html">Avoid unused local variables [OPT-02-4]</A>
<LI><A HREF="OPT-03.html">Eliminate unused parameters [OPT-03-2]</A>
<LI><A HREF="OPT-04.html">Prefer canonical form of ++ and --. Prefer calling the prefix forms [OPT-04-3]</A>
<LI><A HREF="OPT-05.html">Eliminate unused private member variables [OPT-05-3]</A>
<LI><A HREF="OPT-06.html">Avoid unused local variables or variables which have no side effect [OPT-06-4]</A>
<LI><A HREF="OPT-07.html">Prefer &quot;a @= b&quot; than &quot;a = a @ b&quot;, where &quot;@&quot; is +, -, *, /, % [OPT-07-3]</A>
<LI><A HREF="OPT-08.html">Prefer &quot;a @= b&quot; than &quot;a = a @ b&quot;, where &quot;@&quot; is &amp;, |, ^, &lt;&lt;, &gt;&gt; [OPT-08-3]</A>
<LI><A HREF="OPT-09.html">Remove unnecessary '== true' in Boolean functions [OPT-09-5]</A>
<LI><A HREF="OPT-10.html">Do not declare variables in &quot;if&quot;, &quot;for&quot;, &quot;while&quot;, and &quot;do while&quot; statement [OPT-10-3]</A>
<LI><A HREF="OPT-11.html">If a file-level static variable is used/referenced in one function only then include that variable in the function itself [OPT-11-3]</A>
<LI><A HREF="OPT-12.html">If a file-level static variable is used/referenced in one class only then include that variable in the class itself [OPT-12-3]</A>
<LI><A HREF="OPT-13.html">Declare member variables in the descending size order [OPT-13-3]</A>
<LI><A HREF="OPT-14.html">Pass objects by reference instead of by value [OPT-14-3]</A>
<LI><A HREF="OPT-15.html">Consider overloading to avoid implicit type conversions [OPT-15-3]</A>
<LI><A HREF="OPT-16.html">Global function containing recursion, loops or virtual function call should not be inlined [OPT-16-3]</A>
<LI><A HREF="OPT-17.html">Avoid inline constructors and destructors [OPT-17-3]</A>
<LI><A HREF="OPT-18.html">Member function containing recursion or loops should not be inlined [OPT-18-3]</A>
<LI><A HREF="OPT-19.html">Consider using op= instead of stand-alone op [OPT-19-3]</A>
<LI><A HREF="OPT-20.html">Postpone variable definitions as long as possible [OPT-20-3]</A>
<LI><A HREF="OPT-21.html">switch statement which results are invariant shall not be permitted [OPT-21-3]</A>
<LI><A HREF="OPT-22.html">Useless case statement shall not be permitted [OPT-22-3]</A>
<LI><A HREF="OPT-23.html">Trivial accessor and mutator functions should be inlined [OPT-23-4]</A>
<LI><A HREF="OPT-24.html">Trivial forwarding functions should be inlined [OPT-24-4]</A>
<LI><A HREF="OPT-25.html">Only functions with 1 or 2 statements should be considered candidates for inline functions [OPT-25-4]</A>
<LI><A HREF="OPT-26.html">Variables will not be introduced until they can be initialized with meaningful values [OPT-26-2]</A>
<LI><A HREF="OPT-27.html">The number of accessor and mutator functions should be minimized [OPT-27-4]</A>
<LI><A HREF="OPT-28.html">'strlen' function should not be used to check string against NULL/non-NULL [OPT-28-3]</A>
<LI><A HREF="OPT-29.html">Redundant cast to the same type is not allowed [OPT-29-4]</A>
<LI><A HREF="OPT-30.html">Every defined function shall be called at least once [OPT-30-3]</A>
<LI><A HREF="OPT-31.html">There shall be no unused parameters (named or unnamed) in non-virtual functions [OPT-31-3]</A>
<LI><A HREF="OPT-32.html">All functions with void return type shall have external side effect(s) [OPT-32-3]</A>
<LI><A HREF="OPT-33.html">Consider returning object by reference instead of by value [OPT-33-5]</A>
</UL>
<LI><B><A HREF="PB.html">Possible Bugs [PB]</A></B>
<UL>
<LI><A HREF="PB-01.html">Do not dereference pointer type expressions [PB-01-3]</A>
<LI><A HREF="PB-02.html">Do not use assignments inside a(b), a[b], and cast [PB-02-3]</A>
<LI><A HREF="PB-03.html">Using mixed types in ternary operator is not allowed [PB-03-3]</A>
<LI><A HREF="PB-05.html">Return value of a function must match declared return type [PB-05-3]</A>
<LI><A HREF="PB-06.html">Do not assign incompatible variable types [PB-06-3]</A>
<LI><A HREF="PB-07.html">Do not assign function return value to a variable of incompatible type [PB-07-3]</A>
<LI><A HREF="PB-08.html">Do not assign signed constants to unsigned integer variables [PB-08-3]</A>
<LI><A HREF="PB-09.html">Operators should not return value by reference [PB-09-2]</A>
<LI><A HREF="PB-10.html">Don't treat arrays polymorphically [PB-10-3]</A>
<LI><A HREF="PB-11.html">Declared types of formal and actual parameters to functions must match [PB-11-3]</A>
<LI><A HREF="PB-12.html">Do not cast a signed char to an unsigned int [PB-12-3]</A>
<LI><A HREF="PB-13.html">Do not call delete on non-pointers [PB-13-1]</A>
<LI><A HREF="PB-14.html">Incorrect End-Of-String (EOS) definition [PB-14-3]</A>
<LI><A HREF="PB-15.html">Don't assign the dividend of two integers to a floating-point type [PB-15-3]</A>
<LI><A HREF="PB-16.html">Avoid assigning out-of-range value to char type [PB-16-3]</A>
<LI><A HREF="PB-17.html">Avoid assigning out-of-range value to unsigned char type [PB-17-3]</A>
<LI><A HREF="PB-18.html">Avoid overloading on a pointer and a numerical type [PB-18-3]</A>
<LI><A HREF="PB-19.html">Do not create inline non-member functions that contain local static data [PB-19-3]</A>
<LI><A HREF="PB-20.html">Avoid slicing function arguments / return value [PB-20-3]</A>
<LI><A HREF="PB-21.html">Properly terminate character strings [PB-21-1]</A>
<LI><A HREF="PB-22.html">Do not use increment and decrement expressions inside a(b), a[b], and cast [PB-22-3]</A>
<LI><A HREF="PB-23.html">The class object should be passed by reference if the class has non-static pointers and has no declared copy constructor [PB-23-1]</A>
<LI><A HREF="PB-24.html">The definition of a constructor shall not contain default arguments that produce a signature identical to that of the implicitly-declared copy constructor [PB-24-2]</A>
<LI><A HREF="PB-25.html">Unsigned arithmetic shall not be used [PB-25-2]</A>
<LI><A HREF="PB-26.html">Public and protected methods should not be invoked by class constructor [PB-26-2]</A>
<LI><A HREF="PB-27.html">A string literal shall not be modified [PB-27-2]</A>
<LI><A HREF="PB-28.html">The following character sequences shall not appear in header file names: ', \, /*, //, or &quot; [PB-28-2]</A>
<LI><A HREF="PB-29.html">The left-hand operand of a right-shift operator shall not have a negative value [PB-29-2]</A>
<LI><A HREF="PB-30.html">More than one 'enum' type shall not be used as a switch condition or a label in a case statement [PB-30-3]</A>
<LI><A HREF="PB-31.html">Do not call 'sizeof' on constants [PB-31-3]</A>
<LI><A HREF="PB-32.html">Do not call 'sizeof' on a pointer type [PB-32-3]</A>
<LI><A HREF="PB-33.html">Avoid implicit type conversions involving enum types [PB-33-3]</A>
<LI><A HREF="PB-34.html">Third parameter to 'memcpy'/'strncpy'/'memmove' should not depend on second [PB-34-3]</A>
<LI><A HREF="PB-35.html">Assignment operators shall not be used in conditions without brackets [PB-35-3]</A>
<LI><A HREF="PB-36.html">An object's dynamic type shall not be used from the body of its constructor or destructor [PB-36-3]</A>
<LI><A HREF="PB-37.html">The unbounded functions of library &lt;cstring&gt; shall not be used [PB-37-3]</A>
<LI><A HREF="PB-38.html">Narrow and wide string literals shall not be concatenated [PB-38-3]</A>
<LI><A HREF="PB-39.html">A function shall not return a reference or a pointer to a parameter that is passed by reference or const reference [PB-39-3]</A>
<LI><A HREF="PB-40.html">A function shall not return a reference or a pointer to an automatic variable (including parameters), defined within the function [PB-40-3]</A>
<LI><A HREF="PB-41.html">An identifier with array type passed as a function argument shall not decay to a pointer [PB-41-3]</A>
<LI><A HREF="PB-42.html">An object shall not be assigned to an overlapping object [PB-42-3]</A>
<LI><A HREF="PB-43.html">All constructors of a class should explicitly call a constructor for all of its immediate base classes and all virtual base classes [PB-43-3]</A>
<LI><A HREF="PB-44.html">The terminate() function shall not be called implicitly [PB-44-3]</A>
</UL>
<LI><B><A HREF="PFO.html">Physical File Organization [PFO]</A></B>
<UL>
<LI><A HREF="PFO-01.html">Don't define entities with linkage in a header file [PFO-01-3]</A>
<LI><A HREF="PFO-02.html">Use multiple include guards [PFO-02-3]</A>
<LI><A HREF="PFO-03.html">An include file should not contain more than one class definition [PFO-03-3]</A>
<LI><A HREF="PFO-04.html">Include constant string describing file [PFO-04-3]</A>
<LI><A HREF="PFO-05.html">File with extension '.c' may not include other files with extension '.c' [PFO-05-3]</A>
<LI><A HREF="PFO-06.html">Never include other files in a file with extension '.icc' [PFO-06-3]</A>
<LI><A HREF="PFO-07.html">Use multiple include guards with pattern based on the header file name [PFO-07-3]</A>
<LI><A HREF="PFO-08.html">Use mechanism that prevents multiple inclusion of the file i.e. include guards or &quot;#pragma once&quot; preprocessor directive [PFO-08-3]</A>
<LI><A HREF="PFO-09.html">&quot;#pragma once&quot; preprocessor directive should not be used in source files [PFO-09-3]</A>
</UL>
<LI><B><A HREF="PORT.html">Portability [PORT]</A></B>
<UL>
<LI><A HREF="PORT-01.html">Use capital 'L' instead of lowercase 'l' to indicate long [PORT-01-5]</A>
<LI><A HREF="PORT-02.html">Assigning result of ints operation to long without casting at least one of the ints is not allowed [PORT-02-3]</A>
<LI><A HREF="PORT-03.html">Don't use hard coded value of offset in structures [PORT-03-2]</A>
<LI><A HREF="PORT-04.html">Don't use hex constants [PORT-04-3]</A>
<LI><A HREF="PORT-05.html">A pointer to a long should not be casted to an int pointer [PORT-05-2]</A>
<LI><A HREF="PORT-06.html">Do not assign a long int to an int [PORT-06-3]</A>
<LI><A HREF="PORT-07.html">Do not pass long casted to an int in function call [PORT-07-3]</A>
<LI><A HREF="PORT-08.html">Constant assignment to long should not involve int literals [PORT-08-3]</A>
<LI><A HREF="PORT-09.html">The type char shall always be declared as unsigned char or signed char [PORT-09-3]</A>
<LI><A HREF="PORT-10.html">Do not initialize a long int with int literals [PORT-10-3]</A>
<LI><A HREF="PORT-11.html">Do not cast an int pointer to a long pointer [PORT-11-2]</A>
<LI><A HREF="PORT-12.html">Do not assign the value from 32 bit multiplication to long type [PORT-12-3]</A>
<LI><A HREF="PORT-13.html">The type int shall always be declared as unsigned int or signed int [PORT-13-3]</A>
<LI><A HREF="PORT-14.html">Avoid conversions from &quot;shorter&quot; type to &quot;longer&quot; type in assignment [PORT-14-3]</A>
<LI><A HREF="PORT-15.html">Do not cast from &quot;shorter&quot; type to &quot;longer&quot; type [PORT-15-3]</A>
<LI><A HREF="PORT-16.html">Avoid conversions from a &quot;shorter&quot; type to a &quot;longer&quot; type in function calls [PORT-16-3]</A>
<LI><A HREF="PORT-17.html">Don't use i64 or L suffixes directly [PORT-17-3]</A>
<LI><A HREF="PORT-18.html">Don't define i64 or L suffixes directly [PORT-18-3]</A>
<LI><A HREF="PORT-19.html">Instead of casting a long type operand of an expression to int cast the result of the expression [PORT-19-3]</A>
<LI><A HREF="PORT-20.html">Do not declare variables of long type directly [PORT-20-3]</A>
<LI><A HREF="PORT-21.html">Do not assign a long value to a double [PORT-21-3]</A>
<LI><A HREF="PORT-22.html">Use arrays of int types instead of large arrays of longs [PORT-22-5]</A>
<LI><A HREF="PORT-23.html">Use arrays of int types instead of dynamic allocated large arrays of longs [PORT-23-5]</A>
<LI><A HREF="PORT-24.html">Don't use large arrays of pointers to bool, char, short, int and float types [PORT-24-5]</A>
<LI><A HREF="PORT-25.html">User-specified identifiers (internal and external) will not rely on significance of more than 64 characters [PORT-25-2]</A>
<LI><A HREF="PORT-26.html">Algorithms shall not make assumptions concerning the order of allocation of nonstatic data members separated by an access specifier [PORT-26-2]</A>
</UL>
<LI><B><A HREF="PREPROC.html">Preprocessor [PREPROC]</A></B>
<UL>
<LI><A HREF="PREPROC-01.html">Avoid macros [PREPROC-01-3]</A>
<LI><A HREF="PREPROC-02.html">Don't use macros in include statement [PREPROC-02-2]</A>
<LI><A HREF="PREPROC-03.html">Don't redefine primitive types [PREPROC-03-4]</A>
<LI><A HREF="PREPROC-04.html">Don't define part of statement [PREPROC-04-4]</A>
<LI><A HREF="PREPROC-05.html">In a macro function, use parentheses before and after multiplication or division [PREPROC-05-2]</A>
<LI><A HREF="PREPROC-06.html">Do not allow relative path names in #include statements [PREPROC-06-2]</A>
<LI><A HREF="PREPROC-07.html">Incorrect 'NULL' definition [PREPROC-07-5]</A>
<LI><A HREF="PREPROC-08.html">The #include pre-processor directive will only be used to include header (*.h) files [PREPROC-08-3]</A>
<LI><A HREF="PREPROC-09.html">The #include directive shall use the &lt;filename.h&gt; notation to include header files [PREPROC-09-2]</A>
<LI><A HREF="PREPROC-10.html">The #ifndef and #endif pre-processor directives will only be used to prevent multiple inclusions of the same header file [PREPROC-10-3]</A>
<LI><A HREF="PREPROC-11.html">Only the following pre-processor directives shall be used: #ifndef, #define, #endif, #include [PREPROC-11-2]</A>
<LI><A HREF="PREPROC-12.html">C++ macros shall only be used for include guards, type qualifiers, or storage class specifiers [PREPROC-12-3]</A>
<LI><A HREF="PREPROC-13.html">Macro should not contain token pasting, variable argument list nor recursive macro calls [PREPROC-13-3]</A>
<LI><A HREF="PREPROC-14.html">All macros must expand into complete syntactic units [PREPROC-14-3]</A>
<LI><A HREF="PREPROC-15.html">Pointer dereference operations may not be hidden in macro definitions [PREPROC-15-3]</A>
</UL>
<LI><B><A HREF="QT.html">Qt Best Practices [QT]</A></B>
<UL>
<LI><A HREF="QT-01.html">Every QObject subclass should contain a Q_OBJECT macro [QT-01-3]</A>
<LI><A HREF="QT-02.html">QObject must not be inherited more than one time [QT-02-3]</A>
<LI><A HREF="QT-03.html">It's only possible to connect a signal to a slot or a signal to another signal [QT-03-3]</A>
<LI><A HREF="QT-04.html">The methods inside the SIGNAL and SLOT macros have to exist [QT-04-1]</A>
<LI><A HREF="QT-05.html">Mark signal emissions with the keyword &quot;emit&quot; to distinguish a signal emission from a normal method call [QT-05-3]</A>
<LI><A HREF="QT-06.html">Do not set Idle or Critical priority to QThreads. Use High/Low/Med only [QT-06-3]</A>
<LI><A HREF="QT-07.html">Do not force thread termination by calling QThread::terminate() [QT-07-1]</A>
<LI><A HREF="QT-08.html">If using lock on a mutex in a function, release the lock in the same function [QT-08-3]</A>
<LI><A HREF="QT-09.html">Do not call new on QMutexLocker [QT-09-1]</A>
<LI><A HREF="QT-10.html">Declare a copy constructor and operator= for any Qt - inherited objects that have pointers [QT-10-3]</A>
<LI><A HREF="QT-11.html">Do not use setWindowFlags function on a Widget [QT-11-4]</A>
<LI><A HREF="QT-12.html">Do not directly set specific Widget attributes that are set by Qt kernel [QT-12-1]</A>
<LI><A HREF="QT-13.html">Never mix const and non-const iterators in assignment [QT-13-3]</A>
<LI><A HREF="QT-14.html">If you use Q_DECLARE_FLAGS, you must also use Q_DECLARE_OPERATORS_FOR_FLAGS [QT-14-3]</A>
<LI><A HREF="QT-15.html">Q_DECLARE_OPERATORS_FOR_FLAGS must be in the global namespace, Q_DECLARE_FLAGS inside the enum's namespace [QT-15-3]</A>
<LI><A HREF="QT-16.html">The getters and setters of a Q_PROPERTY must exist and the types must match [QT-16-3]</A>
<LI><A HREF="QT-17.html">Properties of enum types must use Q_ENUMS [QT-17-3]</A>
<LI><A HREF="QT-18.html">Non-const function should not be called on the Qt object [QT-18-3]</A>
</UL>
<LI><B><A HREF="SECURITY.html">Security [SECURITY]</A></B>
<UL>
<LI><A HREF="SECURITY-01.html">Avoid functions which use time from standard C library [SECURITY-01-2]</A>
<LI><A HREF="SECURITY-02.html">Avoid functions which use random numbers from standard C library [SECURITY-02-2]</A>
<LI><A HREF="SECURITY-03.html">Usage of system properties should be restricted [SECURITY-03-2]</A>
<LI><A HREF="SECURITY-04.html">Avoid loading Dynamic Link Libraries [SECURITY-04-2]</A>
<LI><A HREF="SECURITY-05.html">Avoid using functions printf/wprintf with only one variable parameter [SECURITY-05-2]</A>
<LI><A HREF="SECURITY-06.html">Avoid functions which use time from MFC library [SECURITY-06-3]</A>
<LI><A HREF="SECURITY-07.html">Don't use unsafe C functions that do write to range-unchecked buffers [SECURITY-07-3]</A>
<LI><A HREF="SECURITY-08.html">Avoid using functions fprintf/fwprintf with only two parameters, when second parameter is a variable [SECURITY-08-2]</A>
<LI><A HREF="SECURITY-09.html">Avoid using data() function from 'string' class of standard library [SECURITY-09-2]</A>
<LI><A HREF="SECURITY-10.html">Avoid using vfork() function [SECURITY-10-2]</A>
<LI><A HREF="SECURITY-11.html">Avoid using unsecured shell functions that may be affected by shell metacharacters [SECURITY-11-2]</A>
<LI><A HREF="SECURITY-12.html">Avoid using unsafe string functions which may cause buffer overflows [SECURITY-12-2]</A>
<LI><A HREF="SECURITY-13.html">Avoid using unsafe string functions that do not check bounds [SECURITY-13-2]</A>
<LI><A HREF="SECURITY-14.html">Do not use scanf and fscanf functions without specifying variable size in format string [SECURITY-14-2]</A>
<LI><A HREF="SECURITY-15.html">Do not print potentially sensitive information, resulting from an application error into exception messages [SECURITY-15-2]</A>
<LI><A HREF="SECURITY-16.html">Never use gets() [SECURITY-16-1]</A>
<LI><A HREF="SECURITY-17.html">Avoid passing non-const parameters or variables into exec [SECURITY-17-2]</A>
<LI><A HREF="SECURITY-18.html">Avoid passing dynamically created strings into exec [SECURITY-18-2]</A>
<LI><A HREF="SECURITY-19.html">Usage of functions prone to race is not allowed [SECURITY-19-2]</A>
<LI><A HREF="SECURITY-20.html">Avoid passing user input into methods as parameters [SECURITY-20-2]</A>
<LI><A HREF="SECURITY-21.html">Do not use 'syslog' function for logging purposes [SECURITY-21-2]</A>
<LI><A HREF="SECURITY-22.html">Do not use mbstowcs() function [SECURITY-22-2]</A>
<LI><A HREF="SECURITY-23.html">Beware of functions which may return the current directory or the windows directory [SECURITY-23-2]</A>
<LI><A HREF="SECURITY-24.html">Avoid using InitializeCriticalSection [SECURITY-24-2]</A>
<LI><A HREF="SECURITY-25.html">Avoid using thread-unsafe functions [SECURITY-25-2]</A>
<LI><A HREF="SECURITY-26.html">Do not use 'setuid' in source code [SECURITY-26-2]</A>
<LI><A HREF="SECURITY-27.html">Don't use chmod(), chown(), chgrp() [SECURITY-27-2]</A>
<LI><A HREF="SECURITY-28.html">Standard random number generators should not be used to generate randomness for security reasons [SECURITY-28-2]</A>
<LI><A HREF="SECURITY-29.html">Do not use obsolete C routine ulimit() [SECURITY-29-2]</A>
<LI><A HREF="SECURITY-30.html">Avoid using 'getpw' function in program code [SECURITY-30-2]</A>
<LI><A HREF="SECURITY-31.html">Do not use 'cuserid' function [SECURITY-31-2]</A>
<LI><A HREF="SECURITY-32.html">Avoid using obsolete C routine 'usleep' [SECURITY-32-2]</A>
<LI><A HREF="SECURITY-33.html">Usage of functions which do not properly handle non-NULL terminated strings is not allowed [SECURITY-33-2]</A>
<LI><A HREF="SECURITY-34.html">Avoid using environment variables [SECURITY-34-2]</A>
<LI><A HREF="SECURITY-35.html">Don't trust any value of command line if attacker can set them [SECURITY-35-2]</A>
<LI><A HREF="SECURITY-36.html">Never use unfiltered data from an untrusted user as the format parameter [SECURITY-36-2]</A>
<LI><A HREF="SECURITY-37.html">Do not use weak encryption functions [SECURITY-37-2]</A>
<LI><A HREF="SECURITY-38.html">Untrusted data is used as a loop boundary [SECURITY-38-2]</A>
</UL>
<LI><B><A HREF="STL.html">STL Best Practices [STL]</A></B>
<UL>
<LI><A HREF="STL-01.html">Instead of trying to write the container-independent code use class encapsulation [STL-01-5]</A>
<LI><A HREF="STL-02.html">To make copying efficient, correct, and immune to the slicing problem create containers of pointers instead of containers of objects [STL-02-3]</A>
<LI><A HREF="STL-03.html">Call empty instead of checking size() against zero [STL-03-3]</A>
<LI><A HREF="STL-04.html">Avoid using iterative calls to insert in an explicit loop [STL-04-3]</A>
<LI><A HREF="STL-05.html">Almost all uses of copy where the destination range is specified using an insert iterator should be replaced with calls to range member functions [STL-05-3]</A>
<LI><A HREF="STL-06.html">Instead of anonymous istream_iterator objects use istream_iterator names when used as function parameters [STL-06-3]</A>
<LI><A HREF="STL-07.html">When using containers of newed pointers, remember to delete the pointers before the container is destroyed [STL-07-3]</A>
<LI><A HREF="STL-08.html">Never create containers of auto_ptrs [STL-08-3]</A>
<LI><A HREF="STL-09.html">Avoid using remove algorithm with list and standard associative containers [STL-09-3]</A>
<LI><A HREF="STL-10.html">Prefer vector and string to dynamically allocated arrays [STL-10-3]</A>
<LI><A HREF="STL-11.html">Consider using vector&lt;char&gt; instead of string [STL-11-4]</A>
<LI><A HREF="STL-12.html">Use reserve to avoid unnecessary reallocations [STL-12-3]</A>
<LI><A HREF="STL-13.html">Each vector and string should be checked if it is not empty before it is passed to C function [STL-13-3]</A>
<LI><A HREF="STL-14.html">Avoid using vector&lt;bool&gt; [STL-14-3]</A>
<LI><A HREF="STL-15.html">Specify comparison types for associative containers of pointers [STL-15-3]</A>
<LI><A HREF="STL-16.html">For associative containers never use comparison function returning true for equal values [STL-16-3]</A>
<LI><A HREF="STL-17.html">For associative containers never use comparison function returning true for equal values [STL-17-3]</A>
<LI><A HREF="STL-18.html">Prefer iterator to const iterator, reverse_iterator, and const_reverse_iterator [STL-18-3]</A>
<LI><A HREF="STL-19.html">Use distance and advance to convert a container's const_iterators to iterators [STL-19-3]</A>
<LI><A HREF="STL-20.html">It is necessary to be careful when using reverse_iterator's base iterator for erasure purposes [STL-20-4]</A>
<LI><A HREF="STL-21.html">Consider istreambuf_iterators for character-by-character input [STL-21-4]</A>
<LI><A HREF="STL-22.html">Make sure destination ranges are big enough [STL-22-3]</A>
<LI><A HREF="STL-23.html">Follow remove-like algorithms by erase if you really want to remove something [STL-23-3]</A>
<LI><A HREF="STL-24.html">Avoid using remove and similar algorithms (i.e., remove_if and unique) on containers of dynamically allocated pointers [STL-24-3]</A>
<LI><A HREF="STL-25.html">If you pass a sorted range to an algorithm that also takes a comparison function, be sure that the comparison function you pass behaves the same as the one you used to sort the range [STL-25-4]</A>
<LI><A HREF="STL-26.html">Proper implementation of copy_if should not be based on returning the remove_copy_if with a not1 in front of the predicate [STL-26-3]</A>
<LI><A HREF="STL-27.html">If accumulate() is used on a container of floating point values, use floating point value as initial one [STL-27-3]</A>
<LI><A HREF="STL-28.html">Design functor classes for pass-by-value [STL-28-3]</A>
<LI><A HREF="STL-29.html">Make predicates const pure functions [STL-29-3]</A>
<LI><A HREF="STL-30.html">Each functor class should has only one operator() function, and it's parameter and return types should be passed to unary_function or binary_function [STL-30-3]</A>
<LI><A HREF="STL-31.html">You must employ ptr_fun, mem_fun, or mem_fun_ref whenever you pass a function to an STL component [STL-31-3]</A>
<LI><A HREF="STL-32.html">Make sure less&lt;T&gt; means operator&lt; [STL-32-3]</A>
<LI><A HREF="STL-33.html">Prefer algorithm calls to hand-written loops [STL-33-3]</A>
<LI><A HREF="STL-34.html">Prefer member functions to algorithms with the same names [STL-34-3]</A>
<LI><A HREF="STL-35.html">Do not rely on the conversion of count()'s nonzero values to true and zero to false [STL-35-3]</A>
<LI><A HREF="STL-36.html">Do not use an iterator range that isn't really a range [STL-36-3]</A>
<LI><A HREF="STL-37.html">Use vector and string instead of arrays [STL-37-3]</A>
<LI><A HREF="STL-38.html">Use != instead of &lt; to compare iterators [STL-38-3]</A>
<LI><A HREF="STL-39.html">Use traits classes in conjunction with overloading [STL-39-3]</A>
<LI><A HREF="STL-40.html">When calling swap, employ a using declaration for std::swap, then call swap without namespace qualification [STL-40-3]</A>
<LI><A HREF="STL-41.html">Do not declare the non-member to be an overloading of std::swap [STL-41-3]</A>
<LI><A HREF="STL-42.html">Member version of swap should never throw exceptions [STL-42-3]</A>
</UL>
<LI><B><A HREF="TEMPL.html">Template [TEMPL]</A></B>
<UL>
<LI><A HREF="TEMPL-01.html">Factor parameter-independent code out of templates [TEMPL-01-3]</A>
<LI><A HREF="TEMPL-02.html">Define non-member functions inside templates when type conversions are desired [TEMPL-02-3]</A>
<LI><A HREF="TEMPL-03.html">Do not overload functions within a template class [TEMPL-03-3]</A>
<LI><A HREF="TEMPL-04.html">In template global functions use 'typename' to identify nested dependent type names [TEMPL-04-3]</A>
<LI><A HREF="TEMPL-05.html">In template classes use 'typename' to identify nested dependent type names [TEMPL-05-3]</A>
<LI><A HREF="TEMPL-06.html">Don't change default arguments of virtual functions in template classes [TEMPL-06-3]</A>
<LI><A HREF="TEMPL-07.html">A copy constructor shall be declared when there is a template constructor with a single parameter that is a generic parameter [TEMPL-07-3]</A>
<LI><A HREF="TEMPL-08.html">The viable function set for a function call should either contain no function specializations, or only contain function specializations [TEMPL-08-3]</A>
<LI><A HREF="TEMPL-09.html">Overloaded function templates shall not be explicitly specialized [TEMPL-09-3]</A>
<LI><A HREF="TEMPL-10.html">All partial and explicit specializations for a template shall be declared in the same file as the declaration of their primary template [TEMPL-10-3]</A>
<LI><A HREF="TEMPL-11.html">A copy assignment operator shall be declared when there is a template assignment operator with a parameter that is a generic parameter [TEMPL-11-3]</A>
<LI><A HREF="TEMPL-12.html">In a class template with a dependent base, any name that may be found in that dependent base shall be referred to using a qualified-id or this-&gt; [TEMPL-12-3]</A>
</UL>
</UL>
</BODY></HTML>
