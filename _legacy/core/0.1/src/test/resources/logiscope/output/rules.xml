<?xml version="1.0"?>
<rules>
<!-- LOGISCOPE RULECHECKER 6.3 -->
<rule key="%48eadercom" priority="CRITICAL">
	<name><![CDATA[HeaderCom]]></name>
	<configKey><![CDATA[%48eadercom]]></configKey>
	<category name="Reliability"/>
	<description><![CDATA[HeaderCom
Definition:
-----------
Module must be preceded by a comment.
It is possible to define a format for this comment depending on the type 
of the module as it is defined in metric type.
The format of the comment is defined as a list of regular expressions 
that shall be found in the header comment in the order of declaration.
Formats are defined by regular expressions. The regular expression 
language is a subset of the one defined by the Posix 1003.2 standard 
(Copyright 1994, the Regents of the University of California). 
A regular expression is comprised of one or more non-empty branches, 
separated by the | character.
A branch is one ore more atomic expressions, concatenated.
Each atom can be followed by the following characters:
* - the expression matches a sequence of 0 or more matches of the atom, 
+ - the expression matches a sequence of 1 or more matches of the atom, 
? - the expression matches a sequence of 0 or 1 match of the atom, 
{i} - the expression matches a sequence of i or more matches of the atom, 
{i,j} - the expression matches a sequence of i through j (inclusive) matches of 
        the atom. 
An atomic expression can be either a regular expression enclosed in (), or:
[...] - a bracket expression, that matches any single character from the list 
         enclosed in [], 
[^...] - a bracket expression that matches any single character not from the rest 
         of the list enclosed in [], 
. - it matches any single character, 
^ - it indicates the beginning of a string (alone it matches the null string at 
        the beginning of a line), 
$ - it indicates the end of a string (alone it matches the null string at the end 
       of a line). 
Example:
--------
" .+_Ptr " matches strings like "abc_Ptr", "hh_Ptr", but not "_Ptr",
" T[a-z]* " matches strings like "Ta", "Tb", "Tz",
" [A-Z][a-z0-9_]* " matches strings like "B1", "Z0", "Pp", "P_1_a".
 
Parameters:
----------
Two lists of character strings: the first one for the header files, 
and the second for the code files. 
Each list begins with the string "HEADER" or "CODE" , followed by strings 
representing the associated regular expressions.
Example:
--------
Write
"Name: [a-z]*"
"Author: [A-Z][a-z]*"
"Date: [0-9][0-9]/[0-9][0-9]/[0-9][0-9]"
"Remarks: .*"
For headers like:
////////////////////////////////////////////////
// Name: program
// Author: Andrieu
// Date: 08/07/96
// Remarks: example of comments
//////////////////////////////////////////////// 
]]></description>
</rule>
<rule key="ansi" priority="BLOCKER">
	<name><![CDATA[Function declaration in ANSI syntax]]></name>
	<configKey><![CDATA[ansi]]></configKey>
	<category name="Reliability"/>
	<description><![CDATA[Definition:
-----------
The function declaration and definition shall be written in ANSI syntax.
It is possible to select two options among the following:
- name: the parameters shall be named, and their type indicated, 
        in function declaration, 
- void: empty parameter lists are forbidden. 
Parameters: 
-----------
A list of character strings composed of the chosen options listed above.
Example:
--------
// do not write
f(a, b)
int a;
char *b
{ ...}
f(int, char*);
f();
// write
f(int a, char *b)
{ ...}
f(int a, char *b);
f(void); 
]]></description>
</rule>
<rule key="asscal" priority="BLOCKER">
	<name><![CDATA[Assignement in function calls]]></name>
	<configKey><![CDATA[asscal]]></configKey>
	<category name="Reliability"/>
	<description><![CDATA[Definition:
-----------
Assignment operators ( = , += , -=, *=, /= , %= , >>= , <<=, &=, |=, ^= , ++ , - - ) 
must not be used inside function calls (the evaluation order is not guaranteed).
Justification:
--------------
Removes ambiguity about the evaluation order.
]]></description>
</rule>
<rule key="asscon" priority="CRITICAL">
	<name><![CDATA[Assignement in conditions]]></name>
	<configKey><![CDATA[asscon]]></configKey>
	<category name="Reliability"/>
	<description><![CDATA[Definition:
-----------
Assignment operators ( = , += , -=, *=, /= , %= , >>= , <<=, &=, |=, ^= , ++ , -- ) 
must not be used inside conditional expression in control statements if, while, 
for and switch.
Justification:
--------------
An instruction such as "if (x=y) { ..." is ambiguous and unclear.
One might think the author wanted to write "if (x==y) {...".
Example:
--------
// do not write
if (x -= dx) { ...
for (i=j=n; --i > 0; j--) { ..
// write
x -= dx;
if (x) { ...
for (i=j=n; i > 0; i--, j--) { ... 
]]></description>
</rule>
<rule key="assexp" priority="CRITICAL">
	<name><![CDATA[Assignement in expressions]]></name>
	<configKey><![CDATA[assexp]]></configKey>
	<category name="Reliability"/>
	<description><![CDATA[Definition:
-----------
Inside an expression:
An lvalue has to be assigned only once, 
With multiple assignments, an assigned lvalue can appear only where it has been 
assigned. 
Justification:
--------------
Removes ambiguity about the evaluation order.
Example:
--------
// do not write
i = t[i++];
a=b=c+a;
i=t[i]=15; 
]]></description>
</rule>
<rule key="assignthis" priority="CRITICAL">
	<name><![CDATA[Check for Assignment to "self" in Operator "="]]></name>
	<configKey><![CDATA[assignthis]]></configKey>
	<category name="Reliability"/>
	<description><![CDATA[Definition:
-----------
Inside the definition of an assignment operator:
- the equality between the parameter and this or *this shall be checked;
- in case of equality, *this must be returned.
(This rule relates to Item 17 in "Effective C++", Scott Meyers).
Justification:
--------------
Ensures that self-assignment will work.
]]></description>
</rule>
<rule key="blockdecl" priority="CRITICAL">
	<name><![CDATA[Declarations in blocks]]></name>
	<configKey><![CDATA[blockdecl]]></configKey>
	<category name="Reliability"/>
	<description><![CDATA[Definition:
-----------
Declarations must appear at the beginning of blocks.
Justification:
--------------
Makes the code easier to read.
]]></description>
</rule>
<rule key="boolean" priority="CRITICAL">
	<name><![CDATA[Use real boolean expressions]]></name>
	<configKey><![CDATA[boolean]]></configKey>
	<category name="Reliability"/>
	<description><![CDATA[Definition:
-----------
The tests in control structures must contain proper boolean expressions.
Justification:
--------------
Makes the code easier to understand.
Example:
--------
// Do not write
while (1) {
    if (test) {
        for (i=1; function_call(i); i++) {
// Write 
AlwaysTrue = true;
while (AlwaysTrue == true) {
    if (test==true) {
        for (i=1; function_call(i)==1; i++) {
]]></description>
</rule>
<rule key="brkcont" priority="CRITICAL">
	<name><![CDATA[Break and continue forbidden]]></name>
	<configKey><![CDATA[brkcont]]></configKey>
	<category name="Reliability"/>
	<description><![CDATA[Definition:
-----------
Break and continue instructions are forbidden inside conditional expressions 
in control statements ( for, do, while ).
Nevertheless, the break instruction is allowed in the block instruction 
of the switch statement.
Parameters:
-----------
C++:
====
None.
JAVA:
=====
A string identifying the type of checking:
* "in_switch" (or no parameter) means that the break are allowed in switch 
statements, break and continue are forbidden everywhere else,
* "without_label" means that any break or continue without a label is allowed,
* "with_label" means that any break and continue with a label is allowed,
break and continue without a label is forbidden everywhere.
Justification:
--------------
Like a goto, these instructions break down code structure. Prohibiting them
in loops makes the code easier to understand.
]]></description>
</rule>
<rule key="cast" priority="CRITICAL">
	<name><![CDATA[Prefer C++-style Casts]]></name>
	<configKey><![CDATA[cast]]></configKey>
	<category name="Reliability"/>
	<description><![CDATA[Definition:
-----------
Use the C++-style casts (static_cast, const_cast, dynamic_cast and reinterpret_cast)
instead of the general-purpose C-style cast.
(This rule relates to Item 2 in "More Effective C++", Scott Meyers).
Justification:
--------------
The C-style cast does not allow to make a distinction between the different types
of casts and it is not easy to detect.
]]></description>
</rule>
<rule key="catchref" priority="CRITICAL">
	<name><![CDATA[Catch Exceptions by Reference]]></name>
	<configKey><![CDATA[catchref]]></configKey>
	<category name="Reliability"/>
	<description><![CDATA[Definition:
-----------
In catch clauses references to exceptions must be indicated.
(This rule relates to Item 13 in "More Effective C++", Scott Meyers).
Justification:
--------------
Improves code efficiency.
]]></description>
</rule>
<rule key="classuse" priority="CRITICAL">
	<name><![CDATA[Hidden class uses]]></name>
	<configKey><![CDATA[classuse]]></configKey>
	<category name="Reliability"/>
	<description><![CDATA[Definition:
-----------
This standard prevents from calling a class method not known in the user class 
(hidden use), through calls in series.
Following expressions are not allowed:
u.v.a
u.v.f()
u.g().a
u.g().f()
As for expressions using the -> operator.
Example:
--------
myWindow.itsButton.push(); 
You manipulate the myWindow object from the Window class; you access to the 
itsButton attribute; 
you directly call the push method on it. 
But only the Window class and its interface, containing itsButton , are normaly 
known, and not the itsButton attribute class, neither its public methods 
(including push).
Example:
--------
Error->pos.line;
There is a hidden use of line , which is not known from Error.
]]></description>
</rule>
<rule key="cmclass" priority="CRITICAL">
	<name><![CDATA[A single class per code file]]></name>
	<configKey><![CDATA[cmclass]]></configKey>
	<category name="Reliability"/>
	<description><![CDATA[Definition:
-----------
In a code file, every function must belong to the same class. 
A C function is considered to belong to the main class.
Parameters:
-----------
A string representing the types of modules (metric type) that should be considered 
as code files.
]]></description>
</rule>
<rule key="cmdef" priority="BLOCKER">
	<name><![CDATA[Classes in code file]]></name>
	<configKey><![CDATA[cmdef]]></configKey>
	<category name="Reliability"/>
	<description><![CDATA[Definition:
-----------
A code file must not contain any class declaration.
Parameters:
-----------
A string representing the types of modules (metric type) that should 
be considered as code files.
]]></description>
</rule>
<rule key="condop" priority="CRITICAL">
	<name><![CDATA[Ternary ?: operator]]></name>
	<configKey><![CDATA[condop]]></configKey>
	<category name="Reliability"/>
	<description><![CDATA[Definition:
-----------
The conditional operator ? ... : ... must not be used.
]]></description>
</rule>
<rule key="const" priority="CRITICAL">
	<name><![CDATA[Literal constants]]></name>
	<configKey><![CDATA[const]]></configKey>
	<category name="Reliability"/>
	<description><![CDATA[Definition:
-----------
Numbers, characters and strings have to be declared as constants instead of being 
used as literals inside a program. The user can list the allowed literal 
constants.
Parameters:
-----------
A list of character strings representing the allowed literal constants.
Note: In the case of constants used in initializing lists 
(concerning array and struct structures), only the first five violations are shown. 
Justification:
--------------
Makes maintenance easier by avoiding the scattering of constants among the code, 
often with the same value.
Example:
--------
// do not write
char tab[100];
int i;
...
if (i == 7) {
p = "Hello World.";
}
// write
#define TAB_SIZE 100
enum i_val { ok =7; ko =11};
const char HelloWorld[] = "Hello World.";
char tab[TAB_SIZE];
i_val i;
...
if (i == ok) {
p = HelloWorld;
}
]]></description>
</rule>
<rule key="constrcpy" priority="CRITICAL">
	<name><![CDATA[Copy contructor]]></name>
	<configKey><![CDATA[constrcpy]]></configKey>
	<category name="Reliability"/>
	<description><![CDATA[Definition:
-----------
Each class must contain its copy constructor explicitly.
Parameters:
-----------
The string "dynalloc" which, if used, indicates that the rule has to be checked
only if there is a class member which is a pointer
Justification:
--------------
Makes sure the author has thought about the way to copy an object of the class.
]]></description>
</rule>
<rule key="constrdef" priority="CRITICAL">
	<name><![CDATA[Default constructor]]></name>
	<configKey><![CDATA[constrdef]]></configKey>
	<category name="Reliability"/>
	<description><![CDATA[Definition:
-----------
Each class must contain its default constructor explicitly.
Justification:
--------------
Makes sure the author has thought about the way to initialize an object of the class.
]]></description>
</rule>
<rule key="constrinit" priority="CRITICAL">
	<name><![CDATA[Prefer Initialization to Assignment in Constructors]]></name>
	<configKey><![CDATA[constrinit]]></configKey>
	<category name="Reliability"/>
	<description><![CDATA[Definition:
-----------
Non static data members must be initialized inside the member initialization list 
of the constructor(s) of the class.
(This rule relates to Item 12 in "Effective C++", Scott Meyers).
Justification:
--------------
Improves code efficiency.
]]></description>
</rule>
<rule key="convnewdel" priority="CRITICAL">
	<name><![CDATA[Adhere to Convention when Writing "new" and "delete" Operators]]></name>
	<configKey><![CDATA[convnewdel]]></configKey>
	<category name="Reliability"/>
	<description><![CDATA[Definition:
-----------
Convention for writing operator new:
- the type of the return value shall be void *;
- the type of the first parameter shall be size_t.
Convention for writing operator delete:
- the type of the return value shall be void;
- the type of  the first parameter shall be void *;
- in case of a second parameter, its type shall be size_t. 
(This rule relates to Item 8 in "Effective C++", Scott Meyers).
Parameters:
-----------
The string "static" which, if used, indicates that operator new and operator
delete shall be declared static.
Justification:
--------------
Keeps the consistency with the default new and delete operators.
]]></description>
</rule>
<rule key="ctrlblock" priority="CRITICAL">
	<name><![CDATA[Blocks in control statements]]></name>
	<configKey><![CDATA[ctrlblock]]></configKey>
	<category name="Reliability"/>
	<description><![CDATA[Definition:
-----------
Block statements shall always be used in control statements (if , for , while , do).
Justification:
--------------
Removes ambiguity about the scope of instructions and makes the code easier to read
and to modify.
Example:
--------
// do not write
if (x == 0) return;
else 
while (x > min) 
  x--;
// write
if (x == 0) {
  return;
} else {
  while (x > min) {
    x--;
  }
} 
]]></description>
</rule>
<rule key="dataptr" priority="CRITICAL">
	<name><![CDATA[Data of Pointer Type]]></name>
	<configKey><![CDATA[dataptr]]></configKey>
	<category name="Reliability"/>
	<description><![CDATA[Definition:
-----------
Class members which are pointers to objects are not allowed.
(This rule relates to Item 10 in "More Effective C++", Scott Meyers).
Justification:
--------------
Prevents resource leaks in constructors and simplifies destructors definitions.
]]></description>
</rule>
<rule key="delarray" priority="CRITICAL">
	<name><![CDATA[Use delete [] for arrays]]></name>
	<configKey><![CDATA[delarray]]></configKey>
	<category name="Reliability"/>
	<description><![CDATA[Definition:
-----------
Empty brackets must be used for delete when de-allocating arrays.
Justification:
--------------
Ensures that the appropriate amount of memory is freed.
Example:
--------
int *table = new int[7];
delete table;      // violation
delete [10] table; // violation
delete [] table;   // ok
Limitations:
------------
There are some limitations to this rule when delete is used followed by a 
variable name. These limitations do not apply in the case where delete is 
followed by a number in brackets.
This rule is not violated in the case of "complex" types: 
Example 1:
int ** myarray = new int[2];
myarray[0] = new int[10];
delete myarray;     // violation
delete myarray[0];  // no violation
Example 2:
class A
{
  public:
    int *tab;
...
};
...
    A var;
    var.tab = new int[10];
    delete var.tab;        // no violation
The rule is also not violated when the new operation is hidden:
int * create_array(int nb)
{
   return (new int[nb]); 
}
...
    int * myarray = create_array(10);
    delete myarray;    // no violation
.REQUIRED newarray
]]></description>
</rule>
<rule key="delifnew" priority="CRITICAL">
	<name><![CDATA[Operator "delete" if you Write Operator "new"]]></name>
	<configKey><![CDATA[delifnew]]></configKey>
	<category name="Reliability"/>
	<description><![CDATA[Definition:
-----------
If operator new is declared  inside a class, then operator delete shall be also 
declared inside the same class.
(This rule relates to Item 10 in "Effective C++", Scott Meyers).
Justification:
--------------
"new" and "delete" operators work together.
]]></description>
</rule>
<rule key="destr" priority="CRITICAL">
	<name><![CDATA[Destructor]]></name>
	<configKey><![CDATA[destr]]></configKey>
	<category name="Reliability"/>
	<description><![CDATA[Definition:
-----------
Each class must contain its destructor explicitly.
]]></description>
</rule>
<rule key="dmaccess" priority="CRITICAL">
	<name><![CDATA[Access to members data]]></name>
	<configKey><![CDATA[dmaccess]]></configKey>
	<category name="Reliability"/>
	<description><![CDATA[Definition:
-----------
The class interface must be purely functional: members data definitions can be 
limited.
Parameters:
----------
A list of character strings corresponding to the forbidden access specifiers for 
the data members.
Justification:
--------------
The good way to modify the state of an object is via its methods, not its data 
members.
The data members of a class should be private or at least protected.
Example:
--------
In order to prevent the use of data members in the public and protected 
access specifiers, the standard may be expressed as below:
STANDARD dmaccess ON LIST "public" "protected" EN LIST END STANDARD 
]]></description>
</rule>
<rule key="excepspec" priority="CRITICAL">
	<name><![CDATA[Exception Specifications]]></name>
	<configKey><![CDATA[excepspec]]></configKey>
	<category name="Reliability"/>
	<description><![CDATA[Definition:
-----------
Do not use exception specifications.
(This rule relates to Item 14 in "More Effective C++", Scott Meyers).
Justification:
--------------
Prevents violations of exception specifications, which are dangerous.
]]></description>
</rule>
<rule key="exprcplx" priority="CRITICAL">
	<name><![CDATA[Expressions complexity]]></name>
	<configKey><![CDATA[exprcplx]]></configKey>
	<category name="Reliability"/>
	<description><![CDATA[Definition:
-----------
Expressions complexity must be smaller than a limit given as a parameter. 
This complexity is calculated with the associated syntactic tree, and its number 
of nodes.
By default, the maximum authorized complexity level is 10.
Parameters:
----------
A number representing the authorized complexity level.
Example:
--------
For instance, this expression: 
(b+c*d) + (b*f(c)*d) 
is composed of 8 operators and 7 operands.
The associated syntactic tree has 16 nodes, so if the limit is under 16, 
there will be a standard violation. 
]]></description>
</rule>
<rule key="exprparenth" priority="CRITICAL">
	<name><![CDATA[Parenthesis in expressions]]></name>
	<configKey><![CDATA[exprparenth]]></configKey>
	<category name="Reliability"/>
	<description><![CDATA[Definition:
-----------
In expressions, every binary and ternary operator has to be put in parenthesis, 
so that the evaluation priorities are not ambiguous.
Use the partpar option to allow the following rules: when the right operand of 
a + or * operator uses the same operator, you can omit parenthesis for it. 
In the same way, you can omit parenthesis in the case of the right operand of an 
assignment operator. Moreover, you can omit parenthesis at the first level of 
the expression.
Parameters:
----------
The character string "partpar", which, if used, allows programmers not to put 
systematically parenthesis, according to the rule above. 
Justification:
--------------
Removes ambiguity about the evaluation priorities.
Example:
--------
// do not write
result = fact / 100 + rem;
// write
result = ((fact / 100) + rem);
// or write, with the partpar option
result = (fact / 100) + rem;
// with the partpar option, write
result = (fact * ind * 100) + rem + 10 + (coeff ** c);
// instead of 
result = ((fact * (ind * 100)) + (rem + (10 + (coeff ** c)))); 
]]></description>
</rule>
<rule key="fntype" priority="CRITICAL">
	<name><![CDATA[Function types]]></name>
	<configKey><![CDATA[fntype]]></configKey>
	<category name="Reliability"/>
	<description><![CDATA[Definition:
-----------
Each function has to declare its type. If nothing is returned, 
it must be declared of void type.
]]></description>
</rule>
<rule key="forinit" priority="CRITICAL">
	<name><![CDATA[Initialize for loop counter in for head]]></name>
	<configKey><![CDATA[forinit]]></configKey>
	<category name="Reliability"/>
	<description><![CDATA[Definition:
-----------
Loop counters (in for loops) are to be initialized in the initialization 
statement within the loop.
The loop counter is determined by the third element of the loop head, 
which is most frequently used to increment the loop counter.
In all the following examples, i is the loop counter. 
Justification:
--------------
This way the loop counter is certain to have been initialized, and with a value 
that is visible alongside with the loop condition and increment. The loop is 
easier to understand and to control.
Example:
--------
for (int i = 0; i &lt; 10; i++) ... // ok 
for (int i; i &lt; 10; i++) ...     // violation
for (int j = 0; j &lt; 10; i++) ... // violation
for (int j = 10; i &lt; j; i++) ... // violation
for (int j = 1; i &lt; funct(j); i+=j) ... // violation
]]></description>
</rule>
<rule key="frndclass" priority="CRITICAL">
	<name><![CDATA[Friend classes.]]></name>
	<configKey><![CDATA[frndclass]]></configKey>
	<category name="Reliability"/>
	<description><![CDATA[Definition:
-----------
If friend classes are used, they must be declared at the beginning of the class 
(before member declaration).
]]></description>
</rule>
<rule key="funcptr" priority="CRITICAL">
	<name><![CDATA[No function pointers]]></name>
	<configKey><![CDATA[funcptr]]></configKey>
	<category name="Reliability"/>
	<description><![CDATA[Definition:
-----------
Do not use function pointers.
]]></description>
</rule>
<rule key="funcres" priority="CRITICAL">
	<name><![CDATA[Reserved functions]]></name>
	<configKey><![CDATA[funcres]]></configKey>
	<category name="Reliability"/>
	<description><![CDATA[Definition:
-----------
This standard prevents from the use of system functions that are non portable 
or dangerous.
You can not use the name of these functions for the declaration or definition 
of functions and for function calls.
Parameters:
-----------
A list of character strings representing the function names considered as reserved.
Justification:
--------------
Prevents from the use of system functions that are non portable or dangerous.
Example:
--------
// if the system function is forbidden, do not write
int system(char *command);
int system(char *command)
{
...
}
system("cp file /tmp"); 
]]></description>
</rule>
<rule key="globinit" priority="CRITICAL">
	<name><![CDATA[Global variable initialization]]></name>
	<configKey><![CDATA[globinit]]></configKey>
	<category name="Reliability"/>
	<description><![CDATA[Definition:
-----------
Global variables must be initialized when they are defined.
Justification:
--------------
Not all compilers give the same default values. Unexpected behaviour can be 
avoided with better control over variable values. Initializing global variables 
when they are declared ensures that they are initialized before being used.
]]></description>
</rule>
<rule key="goto" priority="BLOCKER">
	<name><![CDATA["goto" statement]]></name>
	<configKey><![CDATA[goto]]></configKey>
	<category name="Reliability"/>
	<description><![CDATA[Definition:
-----------
The goto statement must not be used, except with the labels chosen by the user. 
Justification:
--------------
Insures that structured programming rules are respected, so the code is easier
to understand. The goto statement often reveals an analysis error and its 
systematic rejection improves the code structure.
Parameters:
-----------
A list of strings representing the labels that can be used with the goto statement.
]]></description>
</rule>
<rule key="headercom" priority="CRITICAL">
	<name><![CDATA[Function and class header comments]]></name>
	<configKey><![CDATA[headercom]]></configKey>
	<category name="Reliability"/>
	<description><![CDATA[Definition:
-----------
Functions and classes must be preceded by a comment.
It is possible to define a format for this comment depending on the type 
of the function definition or declaration, or class definition: func_glob_def,
func_glob_decl, func_stat_def, func_stat_decl, class.
The format of the comment is defined as a list of regular expressions that 
shall be found in the header comment in the order of declaration.
Parameters:
----------
Five or six lists of character strings concerning the five cases listed above. 
Each list begins with one of the five strings (func_glob_def for instance), 
followed by a string representing the regular expression.
]]></description>
</rule>
<rule key="hmclass" priority="CRITICAL">
	<name><![CDATA[A single class definition per header file]]></name>
	<configKey><![CDATA[hmclass]]></configKey>
	<category name="Reliability"/>
	<description><![CDATA[Definition:
-----------
A header file must not contain more than one class definition.
Nested classes are tolerated.
Parameters:
----------
A string representing the types of modules (metric type) that should be 
considered as header files.
]]></description>
</rule>
<rule key="hmdef" priority="CRITICAL">
	<name><![CDATA[Header module content]]></name>
	<configKey><![CDATA[hmdef]]></configKey>
	<category name="Reliability"/>
	<description><![CDATA[Definition:
-----------
The header files may not contain some of the language statements (data 
and function definitions).
The forbidden language items are function definitions (func-stat-def, 
func-glob-def) 
and data definitions (var-stat, var-glob).
Parameters:
-----------
A string representing the types of modules (metric type) that should be 
considered as header files.
]]></description>
</rule>
<rule key="hmstruct" priority="CRITICAL">
	<name><![CDATA[Header module structure]]></name>
	<configKey><![CDATA[hmstruct]]></configKey>
	<category name="Reliability"/>
	<description><![CDATA[Definition:
-----------
To prevent multiple inclusions of header files, the main structure of 
these files should be:
#ifndef &lt;IDENT&gt;
#define &lt;IDENT&gt;
...
#endif
 
where &lt;IDENT&gt; is an identifier built from the name of the header file.
The comparison is made only on alphanumeric characters and is not case sensitive.
The part of the filename taken into account is between the MINth and the MAXth 
characters (including them). This character string should be found in the 
identifier according to the above comparison rules.
Parameters:
----------
A MINMAX couple of values giving the part of the filename to take into account, 
and a list of character strings giving the list of file types to be considered as 
header files for this rule.
The types are those defined by the metric type .
Example:
--------
// if the parameter is MINMAX 4 9,the following content 
// of file div_audit_env.h is correct
#ifndef AUDIT_H
#define AUDIT_H
...
#endif 
]]></description>
</rule>
<rule key="identfmt" priority="CRITICAL">
	<name><![CDATA[Identifier format]]></name>
	<configKey><![CDATA[identfmt]]></configKey>
	<category name="Reliability"/>
	<description><![CDATA[Definition:
-----------
The identifier of a function, type or variable declared in a module 
must have a format corresponding to the category of the declaration.
In the case of the Ada rule, checking is limited to the objects exported 
by the compilation unit.
It is possible to define a format for specific categories in each language.
For a complete description of the available categories, please refer to each manual.
Parameters:
----------
A list of couples of character strings; the first string of the 
couple represents the declaration category name, the second one the regular 
expression associated to that declaration category (see Headercom: Module 
header comments).
]]></description>
</rule>
<rule key="identl" priority="CRITICAL">
	<name><![CDATA[Identifier length]]></name>
	<configKey><![CDATA[identl]]></configKey>
	<category name="Reliability"/>
	<description><![CDATA[Definition:
-----------
The length of a function, type or variable identifier has to be 
between a minimum and a maximum value.
Parameters:
----------
A list of couples of character strings; the first string of the couple 
represents the declaration category name (refer to the table of the identfmt 
standard), the second one the MINMAX expression associated.
]]></description>
</rule>
<rule key="identres" priority="CRITICAL">
	<name><![CDATA[Reserved identifiers]]></name>
	<configKey><![CDATA[identres]]></configKey>
	<category name="Reliability"/>
	<description><![CDATA[Definition:
-----------
Some identifiers may be forbidden in declarations. 
For instance, names used in compilation directives or in libraries.
Parameters:
----------
A list of character strings representing reserved identifiers.
]]></description>
</rule>
<rule key="imptype" priority="CRITICAL">
	<name><![CDATA[Do not use implicit typing]]></name>
	<configKey><![CDATA[imptype]]></configKey>
	<category name="Reliability"/>
	<description><![CDATA[Definition:
-----------
Function, parameter, attribute or variable types must be declared explicitly.
]]></description>
</rule>
<rule key="incltype" priority="CRITICAL">
	<name><![CDATA[Included modules type]]></name>
	<configKey><![CDATA[incltype]]></configKey>
	<category name="Reliability"/>
	<description><![CDATA[Definition:
-----------
Only some types of modules are allowed to be included in other modules.
By default, no inclusion is allowed.
Parameters:
-----------
Lists of lists of character strings, each list being comprised of a string 
representing a type of module (metric type ), followed by strings representing 
the types of modules that may be included in it.
Example:
--------
In CODE modules it is possible to include HEADER modules. 
So the standard can be expressed as following
STANDARD incltype ON LIST "CODE" "HEADER" EN LIST END STANDARD 
]]></description>
</rule>
<rule key="inldef" priority="CRITICAL">
	<name><![CDATA[Inline functions declarations and definitions]]></name>
	<configKey><![CDATA[inldef]]></configKey>
	<category name="Reliability"/>
	<description><![CDATA[Definition:
-----------
Inline functions must be declared in their class and defined outside of it.
Parameters:
----------
The optional string "private". 
When the parameter is used, private inline functions must be defined in the 
class definitions file (.cpp file), other inline functions must de defined in
the class declaration file (.h file). 
]]></description>
</rule>
<rule key="inlinevirt" priority="CRITICAL">
	<name><![CDATA[Inline Virtual Functions]]></name>
	<configKey><![CDATA[inlinevirt]]></configKey>
	<category name="Reliability"/>
	<description><![CDATA[Definition:
-----------
Virtual functions shall not be declared inline.
(This rule relates to Item 24 in "More Effective C++", Scott Meyers).
Justification:
--------------
Improves code efficiency.
]]></description>
</rule>
<rule key="macrocharset" priority="CRITICAL">
	<name><![CDATA[Characters used in macros]]></name>
	<configKey><![CDATA[macrocharset]]></configKey>
	<category name="Reliability"/>
	<description><![CDATA[Definition:
-----------
Some characters may be forbidden in the writing of the definitions of 
macro-functions and macro-constants (not in their name).
The two cases are treated separately.
Parameters:
----------
A list of two couples of character strings; the first string of the couple 
is "constant" or "function", and the second one a string composed by the 
associated forbidden characters.
Example:
--------
The standard can be expressed as following, to forbid, for macro-constants, 
characters taken in the string @#!&/[]{}~`' and, for macro-functions, 
characters taken in the string #@%.\. 
STANDARD macrocharset ON LIST "constant" "@#!&/[]{}~`'" "function" "#@%.\" END LIST 
END STANDARD 
]]></description>
</rule>
<rule key="macroparenth" priority="CRITICAL">
	<name><![CDATA[Parenthesis macro definitions]]></name>
	<configKey><![CDATA[macroparenth]]></configKey>
	<category name="Reliability"/>
	<description><![CDATA[Definition:
-----------
Each occurrence of the macro parameters shall be enclosed in parenthesis 
(or brackets) inside the macro definition.
Example:
--------
// do not write
#define GET_NAME(obj,ind) obj->name[ind]
// write
#define GET_NAME(obj,ind) (obj)->name[ind] 
]]></description>
</rule>
<rule key="mconst" priority="CRITICAL">
	<name><![CDATA[Macro constant usage]]></name>
	<configKey><![CDATA[mconst]]></configKey>
	<category name="Reliability"/>
	<description><![CDATA[Definition:
-----------
The usage of macro constants shall be limited.
It is possible to choose between three options:
 - var: global or static variables are used for string constants, 
	 other constants could be defined by macros, 
Example:
--------
// write
const char *string = "Hello world!";
#define value 3
// do not write
#define string "Hello world!"
  - const: const data are always used instead of macros, 
Example:
--------
// write
const char *string = "Hello world!";
const int value = 3;
// do not write
#define string "Hello world!"
#define value 3
 
  - nodefine: only compilation flags and macro functions are allowed. 
Example:
--------
// write
#define VERBOSE
#define min(x,y) ((x)<(y)?(x):(y))
// do not write
#define value 3
#define current_value f(tab[0])
 
Parameters:
----------
One of the three character strings explained above.
]]></description>
</rule>
<rule key="mfunc" priority="CRITICAL">
	<name><![CDATA[Inline functions instead of macro functions]]></name>
	<configKey><![CDATA[mfunc]]></configKey>
	<category name="Reliability"/>
	<description><![CDATA[Definition:
-----------
Use inline functions instead of macro-functions.
Example:
--------
// write
inline char *GetName(aClass &object) {
return(object.name);
}
// do not write
#define GetName(s) ((s)->name) 
]]></description>
</rule>
<rule key="mname" priority="CRITICAL">
	<name><![CDATA[File names]]></name>
	<configKey><![CDATA[mname]]></configKey>
	<category name="Reliability"/>
	<description><![CDATA[Definition:
-----------
A file name and the name of the class declared or defined in this file must be 
closely related.
The comparison is made only on alphanumeric characters and is not case sensitive.
The extension of the file name is not taken into account.
The part of the file name taken into account to correspond to the name of the class
is between the MIN and the MAX characters (these included).
This character string should be found in the identifier 
according to the above comparison rules.
Parameters:
----------
A MINMAX couple of values giving the part of the file name to take into account.
Example:
--------
if the MINMAX parameters are 4 and 10, and the file name
is My_Graph_Node.h
then the part of the file name that should be found in
the class name is: GRAPHN
(the first 10 characters: My_Graph_N, minus the first 3: Graph_N, minus non 
alphanumeric characters: GraphN)
Then, the class name that the file is based upon could
be one of the following declarations
class CLA_Graph_Node { ...}
class Graph_Node { ...}
class Graph_Node_Def { ...}
class graphnode { ...}
But not the following ones
class Graph { ...}
class NodeGraph { ...}
]]></description>
</rule>
<rule key="multiass" priority="BLOCKER">
	<name><![CDATA[No multiple assignment.]]></name>
	<configKey><![CDATA[multiass]]></configKey>
	<category name="Reliability"/>
	<description><![CDATA[Definition:
-----------
Assignment operators ( = , += , -=, *=, /= , %= , >>= , <<=, &=, |=, ^= , ++ , -- )
must not be used more than once in each statement (declarations are also checked).
Justification:
--------------
Removes ambiguity about the evaluation order.
Example:
--------
// do not write
b = c = 5;
a = (b++ *c) + 5;
// write
c = 5;
b = c;
b++;
a = (b * c) + 5;
]]></description>
</rule>
<rule key="multinher" priority="CRITICAL">
	<name><![CDATA[Multiple inheritance is only allowed for inheriting abstract classes.]]></name>
	<configKey><![CDATA[multinher]]></configKey>
	<category name="Reliability"/>
	<description><![CDATA[Definition:
-----------
If multiple inheritance is used, the classes inherited must be abstract, that is 
to say that they must contain at least one pure virtual method.
Justification:
--------------
Makes the overall design less complicated and the code easier to understand.
Example:
--------
1st case:
A and B are not abstract classes (they contain no pure virtual methods). 
C inherits A and B: the rule is violated.
2nd case:
A and B are abstract classes (they contain at least one pure virtual method each). 
C inherits A and B: the rule is not violated.
3rd case: 
A is abstract, B is not, C is (has a pure virtual function), and inherits A et B.
C violates the rule, but is abstract for inheriting classes.
.REQUIRED absclass browser
]]></description>
</rule>
<rule key="nonleafabs" priority="CRITICAL">
	<name><![CDATA[Make non-leaf classes abstract]]></name>
	<configKey><![CDATA[nonleafabs]]></configKey>
	<category name="Reliability"/>
	<description><![CDATA[Definition:
-----------
Non-leaf classes shall be abstract.
(This rule relates to Item 33 in "More Effective C++", Scott Meyers).
Justification:
--------------
Helps assignment do what most programmers expect and improves the design of classes.
]]></description>
</rule>
<rule key="nopreproc" priority="CRITICAL">
	<name><![CDATA[No pre-processing instructions may be used]]></name>
	<configKey><![CDATA[nopreproc]]></configKey>
	<category name="Reliability"/>
	<description><![CDATA[Definition:
-----------
No pre-processing instructions may be used, except for those specified in the 
parameter list.
Parameters:
-----------
A list of strings defining the exceptions to this rule. The list can be empty.
"define": #define may be used
"include": #include may be used
"if": #if, #ifdef and #ifndef structures may be used
"pragma": #pragma may be used
"undef": #undef may be used
"line": #line may be used
"error": #error may be used
"none": # may be used alone
By default, only #line and # alone may not be used.
Justification:
--------------
Makes the code easier to read and understand.
]]></description>
</rule>
<rule key="normalnew" priority="CRITICAL">
	<name><![CDATA[Avoid Hiding the "Normal" Form of "new"]]></name>
	<configKey><![CDATA[normalnew]]></configKey>
	<category name="Reliability"/>
	<description><![CDATA[Definition:
-----------
If operator new is declared one or several times inside a class, at least one of
these declarations shall follow the "normal" form:
- the type of the first parameter shall be size_t;
- all other parameters, if any, shall have a default value.
(This rule relates to Item 9 in "Effective C++", Scott Meyers).
Justification:
--------------
Lets the usual invocation form of new available.
]]></description>
</rule>
<rule key="nostruct" priority="CRITICAL">
	<name><![CDATA[the key-word struct is not allowed]]></name>
	<configKey><![CDATA[nostruct]]></configKey>
	<category name="Reliability"/>
	<description><![CDATA[Definition:
-----------
The keyword struct may not be used. If the parameter is specified, only C-style 
structs may be used.
Parameters:
-----------
An optional string may be used (cstruct) to enable C-style structs to be used. 
When the cstruct rule is used, the possibilities allowed in C++ in a struct 
(such as access specifiers: private for example, or methods) are not to be used.
]]></description>
</rule>
<rule key="notemplate" priority="CRITICAL">
	<name><![CDATA[Avoid using templates.]]></name>
	<configKey><![CDATA[notemplate]]></configKey>
	<category name="Reliability"/>
	<description><![CDATA[Definition:
-----------
Do not use templates.
Justification:
--------------
Improves code efficiency.
]]></description>
</rule>
<rule key="nothrow" priority="CRITICAL">
	<name><![CDATA[No exceptions may be raised by the user]]></name>
	<configKey><![CDATA[nothrow]]></configKey>
	<category name="Reliability"/>
	<description><![CDATA[Definition:
-----------
No exceptions may be raised by the user (the key-word throw may not be used).
Justification:
--------------
]]></description>
</rule>
<rule key="nounion" priority="CRITICAL">
	<name><![CDATA[The key-word union is not allowed.]]></name>
	<configKey><![CDATA[nounion]]></configKey>
	<category name="Reliability"/>
	<description><![CDATA[Definition:
-----------
The key-word union is not allowed.
]]></description>
</rule>
<rule key="operass" priority="CRITICAL">
	<name><![CDATA[Assignement operator]]></name>
	<configKey><![CDATA[operass]]></configKey>
	<category name="Reliability"/>
	<description><![CDATA[Definition:
-----------
Each class must explicitely contain at least one assignement operator.
Parameters:
-----------
The string "dynalloc" which, if used, indicates that the rule has to be checked
only if there is a class member which is a pointer
Justification:
--------------
Makes sure the author has thought about the way to assign an object of the class.
]]></description>
</rule>
<rule key="overload" priority="CRITICAL">
	<name><![CDATA[Never overload "&&", "||" and "," operators]]></name>
	<configKey><![CDATA[overload]]></configKey>
	<category name="Reliability"/>
	<description><![CDATA[Definition:
-----------
"&&", "||" and "," operators must not be overloaded.
(This rule relates to Item 7 in "More Effective C++", Scott Meyers).
Justification:
--------------
Makes the code do what most programmers expect.
]]></description>
</rule>
<rule key="parammode" priority="CRITICAL">
	<name><![CDATA[Parameters mode]]></name>
	<configKey><![CDATA[parammode]]></configKey>
	<category name="Reliability"/>
	<description><![CDATA[Definition:
-----------
In function definitions, the parameters mode used (IN, OUT or INOUT) must be 
indicated.
Example:
--------
// write
int Multiply(IN Matrix *m, IN Vector *v, OUT Matrix *result);
 
Parameters:
----------
A list of character strings representing the authorized keywords 
(their order does not matter).
Example:
--------
The standard may be specified as following:
STANDARD parammode ON LIST "IN" "OUT" "INOUT" END LIST END STANDARD 
]]></description>
</rule>
<rule key="parse" priority="CRITICAL">
	<name><![CDATA[Parse error]]></name>
	<configKey><![CDATA[parse]]></configKey>
	<category name="Reliability"/>
	<description><![CDATA[Definition:
-----------
This standard identifies module parts that could not be parsed.
]]></description>
</rule>
<rule key="pmfrtn" priority="CRITICAL">
	<name><![CDATA[Do not return pointer to member data]]></name>
	<configKey><![CDATA[pmfrtn]]></configKey>
	<category name="Reliability"/>
	<description><![CDATA[Definition:
-----------
Member functions must not return a pointer or a non-const reference to
member data.
Justification:
--------------
Helps to ensure that data encapsulation is respected.
.REQUIRED classdata
]]></description>
</rule>
<rule key="prepost" priority="CRITICAL">
	<name><![CDATA[Distinguish between Prefix and Postfix Forms of Increment and Decrement Operators]]></name>
	<configKey><![CDATA[prepost]]></configKey>
	<category name="Reliability"/>
	<description><![CDATA[Definition:
-----------
Increment and decrement operators must be declared in the same manner as 
in the following example:
class Example {
  public:
    Example& operator++();          // prefix ++
    const Example operator++(int);  // postfix ++
    Example& operator--();          // prefix --
    const Example operator--(int);  // postfix --
}
(This rule relates to Item 6 in "More Effective C++", Scott Meyers).
Justification:
--------------
Keeps the consistency with built-in types.
]]></description>
</rule>
<rule key="ptraccess" priority="CRITICAL">
	<name><![CDATA[Pointer access.]]></name>
	<configKey><![CDATA[ptraccess]]></configKey>
	<category name="Reliability"/>
	<description><![CDATA[Definition:
-----------
Use the ptr->fld access to the (*ptr).fld access.
]]></description>
</rule>
<rule key="ptrinit" priority="CRITICAL">
	<name><![CDATA[Pointer initialization]]></name>
	<configKey><![CDATA[ptrinit]]></configKey>
	<category name="Reliability"/>
	<description><![CDATA[Definition:
-----------
Each auto variable that is explicitly declared as a pointer (using *), 
must be initialized when declared.
Example:
--------
// write
int* y=&x;
...
// do not write
int *y ; 
*y=&x ;
...
]]></description>
</rule>
<rule key="refclass" priority="CRITICAL">
	<name><![CDATA[References of Classes]]></name>
	<configKey><![CDATA[refclass]]></configKey>
	<category name="Reliability"/>
	<description><![CDATA[Definition:
-----------
Every parameters of class type shall be passed by reference.
(This rule relates to Item 22 in "Effective C++", Scott Meyers).
Justification:
--------------
Improves the efficency of the code.
]]></description>
</rule>
<rule key="returnthis" priority="CRITICAL">
	<name><![CDATA[Return "*this" in Assignment Operators]]></name>
	<configKey><![CDATA[returnthis]]></configKey>
	<category name="Reliability"/>
	<description><![CDATA[Definition:
-----------
Inside the definition of an assignment operator, the return value shall be "*this".
(This rule relates to Item 15 in "Effective C++", Scott Meyers).
Justification:
--------------
Allows chains of assignments and type conversions.
]]></description>
</rule>
<rule key="rtnlocptr" priority="BLOCKER">
	<name><![CDATA[Do not return pointer to local variable]]></name>
	<configKey><![CDATA[rtnlocptr]]></configKey>
	<category name="Reliability"/>
	<description><![CDATA[Definition:
-----------
Functions must not return a pointer to a non-static local variable.
Justification:
--------------
This avoids dangling references of the pointer to the variable after its lifetime.
]]></description>
</rule>
<rule key="sectord" priority="CRITICAL">
	<name><![CDATA[public, private and protected sections order]]></name>
	<configKey><![CDATA[sectord]]></configKey>
	<category name="Reliability"/>
	<description><![CDATA[Definition:
-----------
In a class declaration, sections defined by the access specifiers must follow 
a particular order, given in the parameters of the rule.
Empty string can be used (in the first position), representing 
the first section without any specifier.
Note: Class definitions have not to contain all the access specifiers 
defined in the standard.
Parameters:
----------
A list of character strings representing the access specifiers in the wanted order.
Example:
--------
if the standard has the following strings in this order: "", "private", 
"protected" and "public", then the following declarations are allowed:
class aClass {
int i ;
protected:
void p();
}
class aClass {
protected:
int i ;
public:
void p();
}
and not the following ones:
class aClass {
protected:
...;
private:
... ;
} 
class aClass {
protected:
...;
protected:
... ;
} 
]]></description>
</rule>
<rule key="sgancstr" priority="CRITICAL">
	<name><![CDATA[All classes must have a same direct or indirect ancestor.]]></name>
	<configKey><![CDATA[sgancstr]]></configKey>
	<category name="Reliability"/>
	<description><![CDATA[Definition:
-----------
All classes must have a same direct or indirect ancestor. The ancestor can be 
specified as a parameter.
Parameters:
-----------
A string representing the name of the ancestor. The parameter is optional. 
.REQUIRED use_graph
]]></description>
</rule>
<rule key="sgdecl" priority="CRITICAL">
	<name><![CDATA[A single variable per declaration]]></name>
	<configKey><![CDATA[sgdecl]]></configKey>
	<category name="Reliability"/>
	<description><![CDATA[Definition:
-----------
Variable declarations have the following formalism: type variable_name. 
It is forbidden to have more than one variable for the same type declarator.
Example:
--------
// write
int width;
int length;
// do not write
int width, length; 
]]></description>
</rule>
<rule key="sglreturn" priority="CRITICAL">
	<name><![CDATA[A single return per function.]]></name>
	<configKey><![CDATA[sglreturn]]></configKey>
	<category name="Reliability"/>
	<description><![CDATA[Definition:
-----------
Only one return instruction is allowed in a function.
Justification:
--------------
Makes the code easier to understand and helps avoid dead branches.
]]></description>
</rule>
<rule key="slcom" priority="CRITICAL">
	<name><![CDATA[Use // comments]]></name>
	<configKey><![CDATA[slcom]]></configKey>
	<category name="Reliability"/>
	<description><![CDATA[Definition:
-----------
C-like comments (/* */) are forbidden. Use only C++-like comments (//).
]]></description>
</rule>
<rule key="slstat" priority="CRITICAL">
	<name><![CDATA[One statement per line]]></name>
	<configKey><![CDATA[slstat]]></configKey>
	<category name="Reliability"/>
	<description><![CDATA[Definition:
-----------
There must not be more than one statement per line. 
A statement followed by a brace (instr { ) or a brace followed by a statement 
({ instr ) is allowed in the same line, but not both of them (instr { instr ).
Example:
--------
// write
x = x0;
y = y0;
while (IsOk(x)) {
x++;
}
// do not write
x = x0; y = y0;
while (IsOk(x)) {x++;} 
]]></description>
</rule>
<rule key="swdef" priority="BLOCKER">
	<name><![CDATA[default within switch]]></name>
	<configKey><![CDATA[swdef]]></configKey>
	<category name="Reliability"/>
	<description><![CDATA[Definition:
-----------
A default case is mandatory within a switch in order to cover unexpected cases.
Parameters:
----------
The character string "last", which, if used, specifies that the default case 
has to be the last one.
]]></description>
</rule>
<rule key="swend" priority="BLOCKER">
	<name><![CDATA[End of cases in a switch]]></name>
	<configKey><![CDATA[swend]]></configKey>
	<category name="Reliability"/>
	<description><![CDATA[Definition:
-----------
Each case in a switch shall end with break , continue , goto , return or exit. 
Several consecutive case labels are allowed.
Parameters:
-----------
The character string "nolast", which, if used, allows not to have one of these 
instructions in the last case.
]]></description>
</rule>
<rule key="tryblock" priority="CRITICAL">
	<name><![CDATA[Try Blocks]]></name>
	<configKey><![CDATA[tryblock]]></configKey>
	<category name="Reliability"/>
	<description><![CDATA[Definition:
-----------
Do not use "try" blocks.
(This rule relates to Item 15 in "More Effective C++", Scott Meyers).
Justification:
--------------
Improves code efficiency.
]]></description>
</rule>
<rule key="trydestr" priority="CRITICAL">
	<name><![CDATA[Try Blocks in Destructors]]></name>
	<configKey><![CDATA[trydestr]]></configKey>
	<category name="Reliability"/>
	<description><![CDATA[Definition:
-----------
If it is not empty, the definition of a constructor must contain a "try" 
and "catch" block.
(This rule relates to Item 11 in "More Effective C++", Scott Meyers).
Justification:
--------------
Prevents the call of terminate in case of exception propagation, and helps ensure
that destructors do everything they are supposed to do.
]]></description>
</rule>
<rule key="typeinher" priority="CRITICAL">
	<name><![CDATA[Inheritence type.]]></name>
	<configKey><![CDATA[typeinher]]></configKey>
	<category name="Reliability"/>
	<description><![CDATA[Definition:
-----------
The inheritence type (public, protected, private) must be specified.
Justification:
--------------
Removes ambiguity.
Example:
--------
class inherclass: public Base1, private Base2
{ ...
]]></description>
</rule>
<rule key="typeres" priority="CRITICAL">
	<name><![CDATA[Reserved types]]></name>
	<configKey><![CDATA[typeres]]></configKey>
	<category name="Reliability"/>
	<description><![CDATA[Definition:
-----------
Some types may be forbidden for variables or functions.
It is possible to define the list of types that are forbidden for variables 
(extern , static , and automatic variables) and the list of types that are 
forbidden for functions.
The type specifiers and qualifiers are forbidden in any order and even if 
they are merged with other specifiers or qualifiers.
These types are allowed in typedef definition.
Parameters:
-----------
Two lists of strings beginning by the keywords "data" or "function".
The other items of the list are strings containing the forbidden groups 
of type specifiers or type qualifiers separated by spaces.
Justification:
--------------
Not relying on predefined types improves code portability.
Example:
--------
The standard may be specified as following:
STANDARD typeres ON 
LIST "data" "int" "char" "register double" END LIST
LIST "function" "unsigned int" "double" END LIST 
END STANDARD 
]]></description>
</rule>
<rule key="vararg" priority="CRITICAL">
	<name><![CDATA[Variable number of parameters]]></name>
	<configKey><![CDATA[vararg]]></configKey>
	<category name="Reliability"/>
	<description><![CDATA[Definition:
-----------
Functions with a variable number of arguments are not allowed.
Parameters of va_list type and ... are forbidden in function declarations.
]]></description>
</rule>
<rule key="varinit" priority="CRITICAL">
	<name><![CDATA[all variables must be initialized before being used.]]></name>
	<configKey><![CDATA[varinit]]></configKey>
	<category name="Reliability"/>
	<description><![CDATA[Definition:
-----------
All variables must be initialized before they are used, without aking into account
on the default value attributed by the compiler.
Global variables, parameters of a function in the function body, and data fields 
of a class in its methods are considered to be initialized.
Justification:
--------------
Not all compilers give the same default values. Unexpected behaviour can be 
avoided with better control over variable values.
Limitations:
------------
This rule is not violated in the following cases: 
If an array, a struct or a class are used, they will be consided initialized as 
soon as a part of them has been initialized.
For example: 
    int a[2];
    int b[2] = {6, 7};
    int h;
    
    a[0] = b[0]; // ok
    h = a[1];    // ok
    struct 
    {
	int i;
	int j;
    } e, f;
    e.i = 0;
    g = e;      // ok
This rule is violated in the following cases where initialization is uncertain:
Using a variable in a function call is considered as "being used": if it is not 
initialized, the rule will be violated. 
This will occur whatever the use of the function, even initializing the variable.
In cases including a conditional initialization, the rule is violated even though 
the variable may well be initialized. 
    int i, j, k;
    j = func();
    if (j)
       i = 0;
    k = i;       // violation 
This applies even when there is an else branch, for example in
    int i, j, k;
    j = func();
    if (j)
       i = 0;
    else 
       i = 5;
    k = i;      // violation       
where initialization is certain. 
In the case of a loop, for example
int j, k;
for (int i=0; i&lt;glob; i++)
   {
   j=func(i);
   }
k = j;    // violation 
where glob is a global variable, depending on the value of glob, j will have been 
initialized or not: the rule is violated, even if the loop condition occurs or not.
]]></description>
</rule>
<rule key="varstruct" priority="CRITICAL">
	<name><![CDATA[struct and union variables]]></name>
	<configKey><![CDATA[varstruct]]></configKey>
	<category name="Reliability"/>
	<description><![CDATA[Definition:
-----------
Variables must not be directly declared using a struct or an union structure.
An intermediate type must be automatically used.
Parameters:
----------
The string "nostruct" which, if used, prevents from declaring a struct or 
union variable except in a typedef structure.
WARNING! This option has no meaning in C++ programs, where class declarations 
are always allowed outside a typedef structure.
Example:
--------
// write
typedef struct {
...
} typeName;
typeName varName;
struct structName;
typedef struct structName {
...
struct structName *ptr;
} typeName;
typeName varName;
// do not write
struct {
...
} varName;
// do not write, if the "nostruct" option is used
struct structName {
...
};
struct structName varName; 
]]></description>
</rule>
<rule key="virtdestr" priority="CRITICAL">
	<name><![CDATA[Virtual destructors]]></name>
	<configKey><![CDATA[virtdestr]]></configKey>
	<category name="Reliability"/>
	<description><![CDATA[Definition:
-----------
Destructors of base classes must be declared virtual.
(This rule relates to Item 14 in "Effective C++", Scott Meyers).
Justification:
--------------
Ensures that base and derived destructors are called before memory deallocation.
]]></description>
</rule>
<rule key="voidptr" priority="CRITICAL">
	<name><![CDATA[No void pointer]]></name>
	<configKey><![CDATA[voidptr]]></configKey>
	<category name="Reliability"/>
	<description><![CDATA[Definition:
-----------
The void pointer (void *) should not be used.
]]></description>
</rule>
</rules>